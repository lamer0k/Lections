= Лекция 3
:imagesdir: Lection3Img
:stem:

== Таймеры
Одна из основных задач таймеров в микроконтроллерах это отсчитывать точные интервалы времени. Но, помимо этого таймеры
могут использоваться для измерения частоты, периодов, генерации ШИМа и переменных сигналов различной формы.
Всего
[horizontal]
TIM9-TIM11:: Самые простые 16 битные таймеры.
TIM2-TIM5:: Таймеры общего назначания. (TIM2 и TIM5 32 битные) (TIM3 и TIM4 16 битные)
TIM1:: Расширенный 16 битный таймер

* Также существуют системный таймер *SysTick* таймер и Watchdog таймер.

[.notes]
--
В данном курсе мы рассмотрим только 32 битные таймеры общего назначения. Самостоятельно можно будет ознакомиться с TIM1.
--

=== Таймеры TIM2 и TIM5, основные особенности
* Таймеры 32 битные (то есть могут считать до 2^32), умеют работать:
- с инкрементальными энкодерами и датчиками Холла,
- несколько таймеров можно синхронизировать между собой.

* Таймеры могут использоваться для:
- Захвата сигнала (Защелкивать значение, когда на выводе порта например 0 сменился на 1)
- Сравнения (Считать до значения в регистре сравнения и установить/сбросить/переключить вывод порта)
- Генерации ШИМ (Генерировать прямоугольный сигнал с различной скважностью на вывод порта)
- Генерации одиночного импульса

=== Таймеры TIM2 и TIM5
* Таймеры могут генеририровать следующие события:
** Переполнение
** Захват сигнала
** Сравнение
** Событие-триггер

=== Таймеры TIM2 и TIM5 начальная запуск
* Таймеры тактируются от шины APB1.

[.notes]
--
Поэтому для каждый отчсет таймера по умолчанию происходит на частоте шины, т.е. если шина *APB1* работает на частоте 1 Мгц,
то один отсчет таймера произойдет через 1 мкс. Таким образом можно организовать измерение времени с разрешением в 1 мкс.
Чтобы таймер заработал, его нужно подключить к системе тактирования, т.е. к шине *APB1*.
--

* Подключение к системе тактирование выполняется через регистр *APB1ENR* модуля *RCC*.

* Входную частоту таймера можно поделить, записав делитель частоты в решистр *PSC*.

* Включение таймера производиться с помощью бита *CEN* в регистре *CR1* модуля таймера (TIM2 или TIM5)


=== Таймеры TIM2 и TIM5 переполнение

[.notes]
--
Как только таймер начал считать, его счетчик будет увеличиваться с каждым тактом подающейся на таймер частоты. Т.е. если
входная частота таймера 1 МГц, то через секунду таймер достчитает до 1 000 000.
--

* Значение счетчика таймера можно прочитать из регистра *CNT*.
- Поскольку таймерs *TIM2* и *TIM5* 32 битных, то переполнение наступит когда в регистре *CNT* будет значение *0xFFFFFFFF*,
нетрудно посчитать, что при частоте работе таймера 1 МГц он переполнится через примерно 71.5 минуты.
- При переполнении таймера, он сгенерирует событие (запрос на прерывание).

* Проверить случилось ли переполнение можно, считав бит *UIF* в регистре *CR*.


=== Таймеры TIM2 и TIM5 режим счета до значения
[.notes]
--
Допустим, нам нужно раз в 71.5 минуты моргнуть светодиодом. Мы можем запустить таймер и и постоянно проверять значение
бита *UIF*, как только оно установится в 1, моргнуть светодиодом.
--
* Используя переполнение невозможно задать таймером произвольный интервал времени.

* Задать производльный интервал можно, используя регистр автоперезагрузки *ARR*. В этот регистр записывается число, до
которого будет идти счет. При достижении этого значения, содержимое счетчика *CNT* обнуляется и формируются прерывание
или запрос DMA (если они разрешены).​

*Например:* мы хотим раз в 1 секунду моргать светодиодом. Частота работы таймера 1 Мгц. Чтобы таймер генерировал запрос на
прерывание каждыые 1 секунду, нужно записать число 1 000 000 в регистр *ARR* и число 0 в регистр *CNT* и после этого
запустить таймер. Как только таймер досчитает до 1 000 000  он выставит флаг *UIF*.

=== Таймеры TIM2 и TIM5 регистры для режима счета
TIMx::CNT::
Cчетный 16/32 разрядный регистр таймера суммирующий, с приходом каждого тактового импульса инкрементирует свое содержимое.
На вычитание работать не может. ​

TIMx::PSC::
16 разрядный регистр - делитель частоты для таймера. Коэффициент деления задается в 16-разрядном регистре, этот
коэффициент можно задать в пределах от 1 до 65536.​

TIMx::ARR:: ​
16/32 разрядный регистр автоперезагрузки. В этот регистр записывается число, до которого будет идти счет. При достижении
этого значения, содержимое счетчика TIMx_CNT обнуляется и формируются прерывание или запрос DMA (если они разрешены).​

TIMx::SR:: ​
Регистр статуса. Можно узнать о всех возможных запросах на прерывания от таймера

=== Таймеры TIM2 и TIM5. Управляющий регистр (CR1)
[.notes]
--
Основные настройки таймера производятся через регистр CR1. Нам понадобятся всего несколько бит.
--
[#Регистр CR1]
.Регистр CR1
image::Pic1.png[400, 1024]

[horizontal]
Bit 2: URS:: Источник генерации прерываний​
* *0*: Любые из следующих событий будут генерировать прерывание или запрос DMA, если они включены:​
** Переполнение счетчика​ или установлен UG бит​
* *1*: Только после переполнения счетчика может сгенерировать прерывание или запрос DMA​

Bit 1: UDIS:: Отключить событие по изменению (Update Event)​
* *0*: UEV включен. Событие по изменению(UEV) генерируются следующими событиями:​
 ** Переполнение счетчика​ или установлен UG бит​
* *1*: UEV отключен. ​

Bit 0 CEN:: Включить счетчик​
* *0*: Counter выключен​
* *1*: Counter включен​


=== Таймеры TIM2 и TIM5. Регистр статуса (SR)
[.notes]
--
Регистр SR хранит статусы запросов на прерывания
--
[#Регистр SR]
.Регистр SR
image::Pic2.png[500, 1024]

[horizontal]
Bit0: UIF:: Флаг прерывания по событию обновления. Бит устанавливается аппаратно, скидываться должен программно​
* *0*: Флаг прерывания сбршен​
* *1*: Флаг прерывания установлен​

=== Работа с таймером в качестве счетчика​
Для организации задержки::

* Подать тактирование на модуль таймера​
* Установить делитель частоты для таймера в регистре *PSC*​
* Установить источник генерации прерываний по событию переполнение с помощью бита *URS* в регистре *CR1*​
* Установить значение до которого счетчик будет считать в регистре перезагрузке *ARR*​
* Скинуть флаг генерации прерывания *UIF* по событию в регистре *SR*​
* Установить начальное значение счетчика в 0 в регистре *CNT*​
* Запустить счетчик с помощью бита *EN* в регистре *CR1*​
* Проверять пока не будет установлен флаг генерации прерывания по событию *UIF* в регистре *SR*​
* Как только флаг установлен остановить счетчик, сбросить бит *EN* в регистре *CR1*, Сбросить флаг генерации прерывания
*UIF* по событию в регистре *SR*


=== Задание 1. Простое
* Светодиоды должны гореть раз в 500 мс​
* Сделать задержку на 500, 1000, 1500 мс, вместо цикла for(..) c с помощью таймера​

