  <html>
    <head>
      <meta charset="utf-8">
      <title>A hackable text editor for the 21st CenturySpell Check packageGet to know Atom!КурсCreate Repository</title>
      <style>
        #wrapper {width: 960px; margin: 0 auto;}
        /* Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment @import statement to use as custom stylesheet */
/*@import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700";*/
article,aside,details,figcaption,figure,footer,header,hgroup,main,nav,section{display:block}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
hr{-moz-box-sizing:content-box;box-sizing:content-box;height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,*::before,*::after{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;font-weight:400;font-style:normal;line-height:1;position:relative;cursor:auto;tab-size:4;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0;direction:ltr}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{font-family:inherit;font-weight:400;font-size:1em;line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em;height:0}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{font-size:1em;line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0;font-size:1em}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
abbr,acronym{text-transform:uppercase;font-size:90%;color:rgba(0,0,0,.8);border-bottom:1px dotted #ddd;cursor:help}
abbr{text-transform:none}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote cite{display:block;font-size:.9375em;color:rgba(0,0,0,.6)}
blockquote cite::before{content:"\2014 \0020"}
blockquote cite a,blockquote cite a:visited{color:rgba(0,0,0,.6)}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:solid 1px #dedede}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{display:table-cell;line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;-webkit-border-radius:4px;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed;word-wrap:break-word}
:not(pre)>code.nobreak{word-wrap:normal}
:not(pre)>code.nowrap{white-space:nowrap}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;-webkit-border-radius:3px;border-radius:3px;-webkit-box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em white inset;box-shadow:0 1px 0 rgba(0,0,0,.2),0 0 0 .1em #fff inset;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin-left:auto;margin-right:auto;margin-top:0;margin-bottom:0;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:-ms-flexbox;display:-webkit-flex;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border-style:solid;border-width:1px;border-color:#e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;-webkit-border-radius:4px;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:100%;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:rgba(255,255,255,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details>summary:first-of-type{cursor:pointer;display:list-item;outline:none;margin-bottom:.75em}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
table.tableblock #preamble>.sectionbody>[class="paragraph"]:first-of-type p{font-size:inherit}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6)}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border-style:solid;border-width:1px;border-color:#e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;-webkit-border-radius:4px;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border-style:solid;border-width:1px;border-color:#dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;-webkit-border-radius:4px;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{-webkit-border-radius:4px;border-radius:4px;word-wrap:break-word;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class="highlight"],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;-webkit-border-radius:4px;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid currentColor;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid currentColor;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt,.quoteblock .quoteblock{margin:0 0 1.25em;padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;text-align:left;margin-right:0}
table.tableblock{max-width:100%;border-collapse:separate}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
td.tableblock>.content>:last-child.sidebarblock{margin-bottom:0}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>thead>tr>.tableblock,table.grid-all>tbody>tr>.tableblock{border-width:0 1px 1px 0}
table.grid-all>tfoot>tr>.tableblock{border-width:1px 1px 0 0}
table.grid-cols>*>tr>.tableblock{border-width:0 1px 0 0}
table.grid-rows>thead>tr>.tableblock,table.grid-rows>tbody>tr>.tableblock{border-width:0 0 1px}
table.grid-rows>tfoot>tr>.tableblock{border-width:1px 0 0}
table.grid-all>*>tr>.tableblock:last-child,table.grid-cols>*>tr>.tableblock:last-child{border-right-width:0}
table.grid-all>tbody>tr:last-child>.tableblock,table.grid-all>thead:last-child>tr>.tableblock,table.grid-rows>tbody>tr:last-child>.tableblock,table.grid-rows>thead:last-child>tr>.tableblock{border-bottom-width:0}
table.frame-all{border-width:1px}
table.frame-sides{border-width:0 1px}
table.frame-topbot,table.frame-ends{border-width:1px 0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{display:table-cell;line-height:1.6;background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist{margin-left:.625em}
ul.checklist li>p:first-child>.fa-square-o:first-child,ul.checklist li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist li>p:first-child>input[type="checkbox"]:first-child{margin-right:.25em}
ul.inline{display:-ms-flexbox;display:-webkit-box;display:flex;-ms-flex-flow:row wrap;-webkit-flex-flow:row wrap;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:solid 4px #fff;-webkit-box-shadow:0 0 0 1px #ddd;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);-webkit-border-radius:100px;border-radius:100px;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;-webkit-box-shadow:0 1px 4px #e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{-webkit-box-shadow:none!important;box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media print,amzn-kf8{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}

      </style>
      <link href='https://fonts.googleapis.com/css?family=Noto+Serif' rel='stylesheet' type='text/css'>
      <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,300,300italic,400italic,600,600italic,700,700italic,800,800italic' rel='stylesheet' type='text/css'>
      <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/default.min.css">
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/asciidoc.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/yaml.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/dockerfile.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/makefile.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/go.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/rust.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/haskell.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/typescript.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scss.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/less.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/handlebars.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/groovy.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/scala.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/bash.min.js"></script>
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/ini.min.js"></script>
      <script>hljs.initHighlightingOnLoad();</script>
    </head>
    <body>
      <div id="wrapper">
        <div class="article">
          <h1 id="__asciidoctor-preview-0__">Курс</h1>
<div id="preamble">
<div class="sectionbody">
<hr>
</div>
<div id="toc" class="toc">
<div id="toctitle">Содержание</div>
<ul class="sectlevel1">
<li><a href="#_предисловие">1. Предисловие</a></li>
<li><a href="#_введение">2. Введение</a></li>
<li><a href="#_лекция_1">3. Лекция 1</a></li>
<li><a href="#_основные_термины_и_определения">4. Основные термины и определения</a></li>
<li><a href="#_среда_разработки_программ_для_микроконтроллера">5. Среда разработки программ для микроконтроллера</a>
<ul class="sectlevel2">
<li><a href="#_состав_интеграционной_среды_разработки_iar_workbench">5.1. Состав интеграционной среды разработки IAR Workbench</a></li>
<li><a href="#_процесс_создания_исполняемого_образа">5.2. Процесс создания исполняемого образа</a></li>
<li><a href="#_трансляция_кода">5.3. Трансляция кода</a></li>
<li><a href="#_компоновка_кода">5.4. Компоновка кода</a></li>
<li><a href="#_запуск_и_отладка">5.5. Запуск и отладка</a></li>
</ul>
</li>
<li><a href="#_запуск_программного_обеспечения">6. Запуск программного обеспечения</a>
<ul class="sectlevel2">
<li><a href="#_инициализация_стека">6.1. Инициализация стека</a></li>
<li><a href="#_инициализация_переменных_в_нулевые_значения">6.2. Инициализация переменных в нулевые значения</a></li>
<li><a href="#_инициализация_переменных">6.3. Инициализация переменных</a></li>
<li><a href="#_запуск_функции_main">6.4. Запуск функции main()</a></li>
<li><a href="#_преимущества_iar_embedded_workbench">6.5. Преимущества IAR Embedded Workbench</a></li>
<li><a href="#_вопросы_по_разделу">6.6. Вопросы по разделу</a></li>
<li><a href="#_запуск_программного_обеспечения_2">6.7. Запуск программного обеспечения</a></li>
</ul>
</li>
<li><a href="#_использование_с">7. Использование С++</a>
<ul class="sectlevel2">
<li><a href="#_программа_на_с">7.1. Программа на С++</a></li>
</ul>
</li>
<li><a href="#_создание_проекта_и_работа_в_iar_workbench">8. Создание проекта и работа в IAR Workbench</a>
<ul class="sectlevel2">
<li><a href="#_выбор_шаблона_проекта">8.1. Выбор шаблона проекта</a></li>
<li><a href="#_выбор_микроконтроллера">8.2. Выбор микроконтроллера</a></li>
<li><a href="#_запуск_в_режиме_отладки">8.3. Запуск в режиме отладки</a></li>
<li><a href="#_запуск_проекта_в_режим_симуляции">8.4. Запуск проекта в режим симуляции</a></li>
<li><a href="#_выбор_внутрисхемного_отладчика">8.5. Выбор внутрисхемного отладчика</a></li>
</ul>
</li>
<li><a href="#_структура_проекта">9. Структура проекта</a>
<ul class="sectlevel2">
<li><a href="#_добавление_файла_cstartup_cpp_в_проект">9.1. Добавление файла (cstartup.cpp) в проект</a></li>
<li><a href="#_начальная_структура_проекта">9.2. Начальная структура проекта</a></li>
<li><a href="#_доступ_к_папке_проекта">9.3. Доступ к папке проекта</a></li>
<li><a href="#_cтруктура_папки_проекта">9.4. Cтруктура папки проекта</a></li>
<li><a href="#_изменение_структуры_проекта">9.5. Изменение структуры проекта</a></li>
<li><a href="#_финальная_структура_проекта">9.6. Финальная структура проекта</a></li>
</ul>
</li>
<li><a href="#_окончательная_настройка_проекта">10. Окончательная настройка проекта</a>
<ul class="sectlevel2">
<li><a href="#_организация_памяти">10.1. Организация памяти</a></li>
<li><a href="#_настройка_области_памяти_в_комповшике">10.2. Настройка области памяти в комповшике</a></li>
<li><a href="#_объектный_файл_и_сегменты">10.3. Объектный файл и сегменты</a></li>
<li><a href="#_атрибуты_сегментов">10.4. Атрибуты сегментов</a></li>
<li><a href="#_предопределенные_имена_сегментов_в_iar_workbench">10.5. Предопределенные имена сегментов в IAR Workbench</a></li>
<li><a href="#_файл_настройки_компоновщика">10.6. Файл настройки компоновщика</a></li>
</ul>
</li>
<li><a href="#_настройка_стека">11. Настройка стека</a>
<ul class="sectlevel2">
<li><a href="#_стек">11.1. Стек</a></li>
<li><a href="#_правила_задания_размера_стека">11.2. Правила задания размера стека</a></li>
<li><a href="#_установка_размера_стека">11.3. Установка размера стека</a></li>
<li><a href="#_контроль_за_размер_стеком">11.4. Контроль за размер стеком</a></li>
<li><a href="#_доступ_к_данным_по_анализу_размеру_стека">11.5. Доступ к данным по анализу размеру стека</a></li>
<li><a href="#_куча">11.6. Куча</a></li>
<li><a href="#_определение_размера_кучи">11.7. Определение размера кучи</a></li>
</ul>
</li>
<li><a href="#_задания">12. Задания</a>
<ul class="sectlevel2">
<li><a href="#_задание_1_лекция_1_задание_1">12.1. Задание 1 #Лекция 1 Задание 1</a></li>
<li><a href="#_задание_2">12.2. Задание 2</a></li>
<li><a href="#_задание_3">12.3. Задание 3</a></li>
</ul>
</li>
<li><a href="#_лекция_2">13. Лекция 2</a></li>
<li><a href="#_портируемость_проекта">14. Портируемость проекта</a>
<ul class="sectlevel2">
<li><a href="#_типы_данных">14.1. Типы данных</a></li>
<li><a href="#_встроенные_типы">14.2. Встроенные типы</a></li>
<li><a href="#_модификаторы_типов_данных">14.3. Модификаторы типов данных</a></li>
<li><a href="#_размеры_типов_данных">14.4. Размеры типов данных</a></li>
<li><a href="#_пользовательские_типы">14.5. Пользовательские типы</a></li>
<li><a href="#_псевдонимы_типов">14.6. Псевдонимы типов</a></li>
<li><a href="#_неявное_преобразование_типов">14.7. Неявное преобразование типов</a></li>
<li><a href="#_явное_преобразование_типов">14.8. Явное преобразование типов</a></li>
<li><a href="#_static_cast">14.9. static_cast</a></li>
<li><a href="#_reinterpret_cast">14.10. reinterpret_cast</a></li>
</ul>
</li>
<li><a href="#_память">15. Память</a>
<ul class="sectlevel2">
<li><a href="#_память_микроконтроллера_cortexm4">15.1. Память микроконтроллера CortexM4</a></li>
<li><a href="#_память_для_расположения_данных">15.2. Память для расположения данных</a></li>
<li><a href="#_указатели">15.3. Указатели</a></li>
<li><a href="#_взятие_адреса_и_разыменование_указателя">15.4. Взятие адреса и разыменование указателя.</a></li>
<li><a href="#_операции_над_указателями">15.5. Операции над указателями</a></li>
<li><a href="#_сложение_указателей">15.6. Сложение указателей</a></li>
<li><a href="#_константный_указатель_и_указатель_на_константу">15.7. Константный указатель и указатель на константу</a></li>
<li><a href="#_ссылка">15.8. Ссылка</a></li>
</ul>
</li>
<li><a href="#_регистр">16. Регистр</a>
<ul class="sectlevel2">
<li><a href="#_регистры_общего_назначения">16.1. Регистры общего назначения</a></li>
<li><a href="#_оперативные_регистры">16.2. Оперативные регистры</a></li>
<li><a href="#_вспомогательные_регистры">16.3. Вспомогательные регистры</a></li>
<li><a href="#_специальные_регистры">16.4. Специальные регистры</a></li>
<li><a href="#_регистр_специального_назачения">16.5. Регистр специального назачения</a></li>
<li><a href="#_пример_регистра_специального_назначения">16.6. Пример регистра специального назначения</a></li>
<li><a href="#_доступ_к_регистру_специального_назначения">16.7. Доступ к регистру специального назначения</a></li>
<li><a href="#_работа_с_регистрами_периферии_через_обертку_на_с">16.8. Работа с регистрами периферии через обертку на С++</a></li>
<li><a href="#_некоторые_моменты_при_работе_с_оберткой_с_для_регистров">16.9. Некоторые моменты при работе с оберткой С++ для регистров</a></li>
</ul>
</li>
<li><a href="#_соглашение_об_вызовах">17. Соглашение об вызовах</a>
<ul class="sectlevel2">
<li><a href="#_объявление_функции">17.1. Объявление функции</a></li>
<li><a href="#_компоновка_с_и_с_кода">17.2. Компоновка С и С++ кода</a></li>
<li><a href="#_вход_в_функцию">17.3. Вход в функцию</a></li>
<li><a href="#_выход_из_функции">17.4. Выход из функции</a></li>
<li><a href="#_операторы">17.5. Операторы</a></li>
<li><a href="#_арифметические_операторы">17.6. Арифметические операторы</a></li>
<li><a href="#_логические_операторы">17.7. Логические операторы</a></li>
<li><a href="#_побитовые_операторы">17.8. Побитовые операторы</a></li>
</ul>
</li>
<li><a href="#_отладочная_плата">18. Отладочная плата</a></li>
<li><a href="#_микроконтроллер_st32f411re">19. Микроконтроллер ST32F411RE</a>
<ul class="sectlevel2">
<li><a href="#_ядро_cortexm4">19.1. Ядро CortexM4</a></li>
<li><a href="#_характеристики_ядра_cortexm4">19.2. Характеристики ядра CortexM4</a></li>
<li><a href="#_характеристики_микроконтроллера">19.3. Характеристики микроконтроллера</a></li>
<li><a href="#_блок_диаграмма_микроконтроллера">19.4. Блок диаграмма микроконтроллера</a></li>
<li><a href="#_дополнительные_особенности_микроконтроллера">19.5. Дополнительные особенности микроконтроллера</a></li>
</ul>
</li>
<li><a href="#_система_тактирования">20. Система тактирования</a></li>
<li><a href="#_блок_диаграмма_системы_тактирования">21. Блок диаграмма системы тактирования</a>
<ul class="sectlevel2">
<li><a href="#_модуль_тактирования">21.1. Модуль тактирования.</a></li>
<li><a href="#_фазовая_подстройка_частоты_pll">21.2. Фазовая подстройка частоты PLL</a></li>
<li><a href="#_дополнительные_генераторы_тактовой_частоты">21.3. Дополнительные генераторы тактовой частоты​</a></li>
<li><a href="#_регистр_управления_частотой">21.4. Регистр управления частотой.</a></li>
<li><a href="#_регистр_управления_частотой_контроль">21.5. Регистр управления частотой. Контроль</a></li>
<li><a href="#_регистр_конфигурации_частоты_выбор_источника">21.6. Регистр конфигурации частоты. Выбор источника</a></li>
<li><a href="#_регистр_конфигурации_частоты_делители">21.7. Регистр конфигурации частоты. Делители</a></li>
<li><a href="#_алгоритм_настройки_частоты">21.8. Алгоритм настройки частоты​</a></li>
</ul>
</li>
<li><a href="#_контрольные_вопросы">22. Контрольные вопросы</a></li>
<li><a href="#_задания_2">23. Задания</a>
<ul class="sectlevel2">
<li><a href="#_содержание_отчета">23.1. Содержание отчета</a></li>
<li><a href="#_задание_1">23.2. Задание 1</a></li>
<li><a href="#_задание_2_2">23.3. Задание 2</a></li>
<li><a href="#_задание_3_2">23.4. Задание 3</a></li>
</ul>
</li>
<li><a href="#_библиография">24. Библиография</a></li>
</ul>
</div>
</div>
<div class="sect1">
<h2 id="_предисловие">1. Предисловие</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-2__" class="paragraph">
<p>Специальность “Информационно-измерительная техника” направлена на создание и применение устройств и
систем, составляющих основу информационных технологий в различных отраслях промышленности.
Особое внимание должно уделяться компьютерной или микропроцессорной техники как со стороны
аппаратного, так и программного обеспечения.</p>
</div>
<div id="__asciidoctor-preview-3__" class="paragraph">
<p>В современном мире неотъемлемой частью практически любого измерительного устройства является
микроконтроллер. Важной особенностью применения микроконтроллеров в измерительных устройствах
является тот факт, что для надежной работы такого устройства необходимо не только надежная
аппаратура, но и качественное и надежное программное обеспечение управляющее микроконтроллером.
В настоящее время существует очень много методических пособий и книг по разработке устройств с
использованием микроконтроллеров, однако вопросы разработки программного обеспечения сводятся к
простым примерам на языке ассемблера и Си. Кроме того, существующие пособия значительно отстают от
быстроменяющихся изменений в микропроцессорной технике и тем более языках программирования.
Если еще недавно прорывом в программирование был выход стандарта С11, то уже сегодня существует
стандарт С20 и уже активна работа по стандарту С++23. Следует также заменить, что автором не
найдено ни одной книги или пособия, которые бы затрагивали, например, такие области разработки ПО
для микроконтроллеров, как архитектура программного обеспечения, использования UML и средств
моделирования архитектуры.</p>
</div>
<div id="__asciidoctor-preview-4__" class="paragraph">
<p>Предыдущие методические пособия для курса ПОИП, например,  <a href="#2">[2]</a> были ориентированы на широкие области
применения информационных технологий, начиная от микроконтроллеров и заканчивая базами данных.
Однако по мнению автора, невозможно хорошо разобраться и усвоить столь большой объем разноплановой
информации. В итоге курс и лабораторные работы дают лишь поверхностное представление о разработке
программного обеспечения, а будущие инженеры не до конца усваивают материал и не могут детально
разобраться в принципах разработки программного обеспечения для измерительных устройств. Основываясь
на данном предубеждение, автором выбран иной путь, а именно более узкоспециализированное и
детальное рассмотрение принципов разработки программного обеспечения измерительных устройств на
базе современных микроконтроллеров.</p>
</div>
<div id="__asciidoctor-preview-5__" class="paragraph">
<p>Большую помощь в разработке методического материала оказал обучающийся на кафедре ИнИТ Загоскин Я.
Современные быстроизменяющиеся и эволюционирующие условия диктуют и новый подход к образованию, а
именно все больший упор делается на самообразование, самоусовершенствование и самостоятельный поиск
нужной информации с технической документации, системах поиска, книгах.</p>
</div>
<div id="__asciidoctor-preview-6__" class="paragraph">
<p>Поэтому довольно большая часть разделов предлагается студентам для самостоятельного изучения и
выполнения в качестве домашней практической работы.
Большое влияние на составление данного методического пособия оказал труд <a href="#1">[1]</a> Недяка С.П., Шаропина
Ю.Б. откуда были заимствованы некоторые подходы и организационная структура методического пособия.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_введение">2. Введение</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-7__" class="paragraph">
<p>Данное методическое пособие предназначено для выполнения лабораторных работ с использованием
отладочных плат XNUCLEO F411RE для измерения физических величин на основе микроконтроллера STM32F411
с архитектурой Cortex-M4, операционной системы реального времени FreeRtos и языка программирования
С++ 14 интегрированной средой разработки IAR Embedded Workbench for ARM ver. 8.20</p>
</div>
<div id="__asciidoctor-preview-8__" class="paragraph">
<p>Методическое пособие написано в рамках курса “Программное обеспечение измерительных процессов”, но
оно будет полезным всем желающим освоить принципы разработки измерительных устройств на современных
микроконтроллерах.</p>
</div>
<div id="__asciidoctor-preview-9__" class="paragraph">
<p>Предполагается, что для изучения данного курса у студентов есть хорошие знания микропроцессорной
техники и навыки разработки ПО на языке С++ полученные на ранних курсах.</p>
</div>
<div id="__asciidoctor-preview-10__" class="paragraph">
<p>Методическое пособие состоит из 3 разделов. Первая часть ориентирована на создание проекта в IAR
Embedded Workbench,  работу с периферией микроконтроллера и возможности отладки системы IAR Embedded
Workbench, работе с детальной разработкой простых классов на языке UML в пакете starUML. Вторая
часть посвящена использованию прерываний, работе с операционной системой FreeRtos взаимодействию
между задачами. Заключительная часть ориентирована на принцип разработки архитектуры программного
обеспечения, шаблонам проектирования, разработки детальной архитектуры.</p>
</div>
<div id="__asciidoctor-preview-11__" class="paragraph">
<p>Модули связаны с курсовым проектированием в котором буду задействованы все части данного
методического пособия.</p>
</div>
<div id="__asciidoctor-preview-12__" class="paragraph">
<p>В 2017 году компания “Метран” безвозмездно предоставила ЮУрГУ на кафедру информационно-измерительная
техника 10 отладочных комплектов на базе микропроцессора Stm32F411RE на ядре Cortex M4 с различными
модулями расширения включающие в себя модули Bluetooth, WiFi, графическим индикатором, различными
сенсорами, включающие в себя датчики Холла, датчики влажности, температуры, звука, освещенности,
дыма, положения и многое другое. По этой причине курс ПОИП и лабораторный практикум выполняется
на отладочных платах XNUCLEO 411RE.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_лекция_1">3. Лекция 1</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_основные_термины_и_определения">4. Основные термины и определения</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-13__" class="listingblock">
<div class="title">Встраиваемые вычислительные системы (Embedded systems)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Встраииваемая система (встроенная систеима, англ. embedded system) — специализированная
микропроцессорная система управления, концепция разработки которой заключается в том, что такая
система будет работать, будучи встроенной непосредственно в устройство, которым она управляет.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-14__" class="listingblock">
<div class="title">Микроконтроллер (англ. Micro Controller Unit, MCU)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Микросхема, предназначенная для управления электронными устройствами. Типичный микроконтроллер
сочетает на одном кристалле функции процессора и периферийных устройств, содержит ОЗУ и (или) ПЗУ.
По сути, это однокристальный компьютер, способный выполнять простые задачи.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-15__" class="listingblock">
<div class="title">Контроллер</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">1. Изделие для автоматизации и управления.
2. Микросхема или часть микросхемы реализующая отдельную функцию или задачу управления.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-16__" class="listingblock">
<div class="title">Отладочная, oценочная или демонстрационная плата</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Электронный модуль, как правило, в бескорпусном изготовлении, содержащий минимально необходимый
набор микросхем для разработки ПО для МК.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-17__" class="listingblock">
<div class="title">Интегрированная среда разработки. IDE(англ. IDE, Integrated development environment)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Cистема программных средств, используемая программистами для разработки программного обеспечения.
Обычно, среда разработки включает в себя:
      ⦁	текстовый редактор,
      ⦁	компилятор и/или интерпретатор,
      ⦁	средства автоматизации сборки,
      ⦁	отладчик.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-18__" class="listingblock">
<div class="title">SWD - Serial Wire Debug.</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Двухпроводной отладочный порт</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-19__" class="listingblock">
<div class="title">Компилятор</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Программа выполняющая трансляцию исходного кода из предметно-ориентированногоязыка на мишинно-
ориентированный язык.</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-20__" class="listingblock">
<div class="title">Компоновщик(Линковщик)</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Программа собриющая исходный код на машино-ориентированном языке и производящую сборку в исполняемый
модуль</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-21__" class="listingblock">
<div class="title">Стек</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Абстрактный тип данных, представляющий собой список элементов,организованных по принципу LIFO
(англ. last in — first out,«последним пришёл — первым вышел»).

Возможны три операции со стеком: добавление элемента (иначе проталкивание, push), удаление элемента
(pop) и чтение головного элемента (peek).
Мы будем использовать определение Стека, в значении Аппартный стек</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-22__" class="listingblock">
<div class="title">Аппаратный стек</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">В микроконтроллере стек - это непрерывная область памяти, адресуемая специальными регистрами SP
(указатель стека)</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-23__" class="listingblock">
<div class="title">Регистр</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Сверхбыстрая память внутри процессора, предназначенная для хранения адресов и промежуточных
результатов вычислений (регистр общего назначения/регистр данных) или данных, необходимых для
работы самого процессора.</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_среда_разработки_программ_для_микроконтроллера">5. Среда разработки программ для микроконтроллера</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-24__" class="paragraph">
<p>В учебных целях мы будем использовать интегрированную среду разработки IAR Workbench for ARM.
Компания IAR бесплатно предлагает для ознакомления две версии своего продукта: версию evolution c
полным функционалом и ограничением времени использования 30 дней и версию kickstart (в имени
дистрибутива есть буквы KS) c ограничением на размер генерSируемого исполняемого кода -32 кбайт), но
без ограничения времени использования.</p>
</div>
<div id="__asciidoctor-preview-25__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-26__" class="paragraph">
<p>Еще каких-то 10-15 лет назад для создания простейших программ, минимально необходимым набором
инструментального ПО являлись: текстовый редактор, транслятор ассемблерного кода и симуляторы для
отладки. С развитием микропроцессоров, с ростом объема оперативной памяти и памяти программ и
широчайшим распространением МК в различных областях техники, а также требований к надежности и
качеству разрабатываемого  программного обеспечения минимального набора стало не хватать.</p>
</div>
<div id="__asciidoctor-preview-27__" class="paragraph">
<p>Для создания качественных программ и повторного использования уже отлаженного кода, в виде библиотек,
появились редакторы связей (линковщики, компоновщики), появились отладчики, и более совершенные
трансляторы и, наконец, стало возможным и обоснованным применение компиляторов (примерно с середины
90-х прошлого века), появился диалект Embedded C\C++. И все эти средства для удобства использования
стали объединять в один программный продукт - так появились интегрированные среды разработки (IDE) и
целая отрасль разработки ПО. Одними из лидеров в этой области являются фирмы IAR Systems."</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-28__" class="paragraph">
<p>Для студенческих нужд размера кода в 32КБ более чем достаточно. В курсе мы будем использовать IAR
Embedded Workbench for ARM ver 8.40. Состав этого инструмента показан на Рисунке <a href="#IAR Workbench">[IAR Workbench]</a>.</p>
</div>
<div class="sect2">
<h3 id="_состав_интеграционной_среды_разработки_iar_workbench">5.1. Состав интеграционной среды разработки IAR Workbench</h3>
<div id="__asciidoctor-preview-29__" class="paragraph">
<p>Процесс разработки программного обеспечения в общем случае ничем не отличается от процесса
разработки приложения для обычных компьютеров, который включает в себя проектирование (Design),
разработка кода(Develop), отладка(Debug)</p>
</div>
<div id="__asciidoctor-preview-30__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure1.png" alt="500" width="500">
</div>
<div class="title">Рисунок 1. Процесс разработки с точки зрения IAR Workbench</div>
</div>
</div>
<div class="sect2">
<h3 id="_процесс_создания_исполняемого_образа">5.2. Процесс создания исполняемого образа</h3>
<div id="__asciidoctor-preview-31__" class="paragraph">
<p>Процесс преобразования кода на языке программирования высокого уровня С++ в файл, содержащий образ
исполняемой программы, готовый для прошивки в микроконтроллер можно разделить на два этапа:</p>
</div>
<div id="__asciidoctor-preview-32__" class="ulist">
<ul>
<li id="__asciidoctor-preview-33__">
<p>Трансляция кода в объектный файл</p>
</li>
<li id="__asciidoctor-preview-34__">
<p>Компоновка кода в исполнительный файл</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_трансляция_кода">5.3. Трансляция кода</h3>
<div id="__asciidoctor-preview-35__" class="paragraph">
<p>Трансляцию кода выполняет компилятор. Структурно процесс трансляции с помощью компилятора показан
на рисунке <a href="#Схема Трансляции">[Схема Трансляции]</a>. После трансляции вы можете получить на выходе либо  файлы
библиотеки, которые впоследствии можно будет использовать в других проектах, либо объектные файлы.</p>
</div>
<div id="__asciidoctor-preview-36__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure2.png" alt="500" width="500">
</div>
<div class="title">Рисунок 2. Схема процесса трансляции</div>
</div>
</div>
<div class="sect2">
<h3 id="_компоновка_кода">5.4. Компоновка кода</h3>
<div id="__asciidoctor-preview-37__" class="paragraph">
<p>Компоновку кода выполняет линковщик. Структурно процесс  компоновки с помощью линковщика показан на
<a href="#Схема компоновки">[Схема компоновки]</a>.</p>
</div>
<div id="__asciidoctor-preview-38__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-39__" class="paragraph">
<p>На входе линковщика могут быть, внешние библиотеки, полученные на этапе трансляции в других проектах
и программах, объектные файлы полученные на предыдущем этапе,стандартные(встроенные) библиотеки С++,
и конфигурационный файл, описывающий настройки по размещению кода и данных в адресном пространстве
микроконтроллера. Компоновщик создает исполняемый файл, который можно запустить на микроконтроллере</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-40__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure3.png" alt="500" width="500">
</div>
<div class="title">Рисунок 3. Схема процесса компоновки</div>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_и_отладка">5.5. Запуск и отладка</h3>
<div id="__asciidoctor-preview-41__" class="paragraph">
<p>Последний этап, показаный на рисунке <a href="#IAR Workbench">[IAR Workbench]</a> - отладка. Компоновищик IAR создает файл в
формате ELF, который содержит исполняемый образ программы. Этот файл может быть использован для:</p>
</div>
<div id="__asciidoctor-preview-42__" class="ulist">
<ul>
<li id="__asciidoctor-preview-43__">
<p>Загрузки в систему отладки IAR-CSPY или в любой другой отладчик, например GDB, способный читать
ELF формат</p>
</li>
<li id="__asciidoctor-preview-44__">
<p>Загрузки образа в ПЗУ микроконтроллера используя программатор.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-45__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure4.png" alt="350" width="350">
</div>
<div class="title">Рисунок 4. Возможные варианты использования выходного файла</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_запуск_программного_обеспечения">6. Запуск программного обеспечения</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-46__" class="paragraph">
<p>Функция int main() является точкой входа программы, для пользователя программа начинается с вызова
этой функции и выполнения тела это функции. Однако на самом деле, еще до функции main()
микроконтроллер выполняет множество различных действий, например, инициализацию стека, глобальных
переменных, констант.</p>
</div>
<div class="sect2">
<h3 id="_инициализация_стека">6.1. Инициализация стека</h3>
<div id="__asciidoctor-preview-47__" class="paragraph">
<p>Сразу после подачи питания происходит инициализации указателя стека на конечный адрес стека.</p>
</div>
<div id="__asciidoctor-preview-48__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure5.png" alt="500" width="500">
</div>
<div class="title">Рисунок 5. Стадия инициализации стека</div>
</div>
</div>
<div class="sect2">
<h3 id="_инициализация_переменных_в_нулевые_значения">6.2. Инициализация переменных в нулевые значения</h3>
<div id="__asciidoctor-preview-49__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-50__" class="paragraph">
<p>После подачи питания на микроконтроллер, регистр адреса команды указывает на 0 адрес,
микроконтроллер начинает работу с адреса 0. По адресу 0, находится таблица векторов перываний, по
начальному вектору находится команда инициализации указателя стека на конечный адрес стека и далее
перехода на функцию инициализации.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-51__" class="paragraph">
<p>После подачи питания и инифциализации стека, выполняется функция инициализации памяти нулями (данные
указанные как zero-initialized data, непроинциализированные глобальные переменные, такие как int i;)</p>
</div>
<div id="__asciidoctor-preview-52__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure6.png" alt="450" width="450">
</div>
<div class="title">Рисунок 6. Стадия инициализации непроинициализированных переменных</div>
</div>
</div>
<div class="sect2">
<h3 id="_инициализация_переменных">6.3. Инициализация переменных</h3>
<div id="__asciidoctor-preview-53__" class="paragraph">
<p>Далее должна произойти инициализация данных определенных как initialized data,например int i = 6.
Значения инициализации для каждой переменной будут скопированы из ПЗУ в ОЗУ.</p>
</div>
<div id="__asciidoctor-preview-54__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure7.png" alt="400" width="400">
</div>
<div class="title">Рисунок 7. Стадия инициализации проинициализированных переменных</div>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_функции_main">6.4. Запуск функции main()</h3>
<div id="__asciidoctor-preview-55__" class="paragraph">
<p>Завершающий этап – это вызов функции main().</p>
</div>
<div id="__asciidoctor-preview-56__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure8.png" alt="350" width="350">
</div>
<div class="title">Рисунок 8. Стадия запуска функции main()</div>
</div>
<div id="__asciidoctor-preview-57__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-58__" class="paragraph">
<p>Как видно, перед тем как запуститься функция main необходимо выполнить инициализацию стека и
переменных, кроме того, если в вашем проекте будут использоваться прерывания, то в таблицу векторов
прерываний необходимо добавить переходы на адреса обработчиков ваших прерываний.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_преимущества_iar_embedded_workbench">6.5. Преимущества IAR Embedded Workbench</h3>
<div id="__asciidoctor-preview-59__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-60__" class="paragraph">
<p>За последние время в среде разработки IAR Embedded был сделан огромный скачек с точки зрения
удобства использования, так и с точки зрения поддержки современных стандартов. Так версия 8.X
получила поддержку стандарта С14, а начиная с версии 8.40 и поддержку стандарт С17 и это
является огромным плюсом для разработки надежного, понятного и качественно ПО. Свои мысли по этому
поводу я озвучил в статье <a href="#Можно ли использовать С++ вместо Си для небольших проектов в микроконтроллерах:">[Можно ли использовать С++ вместо Си для небольших проектов в микроконтроллерах:]</a></p>
</div>
<div id="__asciidoctor-preview-61__" class="paragraph">
<p>Некоторые характеристики среды вы можете получить из Таблицы -
<a href="#Характеристики IAR Embedded Workbench">[Характеристики IAR Embedded Workbench]</a>, данные взяты из <a href="#IAR C/C++ Development Guide">[IAR C/C++ Development Guide]</a></p>
</div>
</div>
</div>
<table id="__asciidoctor-preview-62__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 1. Характеристики IAR Embedded Workbench</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Характеристика</th>
<th class="tableblock halign-left valign-top">IAR Embedded Workbench</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Языки</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">С/C++</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Стандарты языка</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">С++ 17 начиная с версии 8.40</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Оптимизация кода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Да, кроме condition_variable, future, mutex, shared_mutex, thread, поддержка
atomic урезана и реализована только для типов для которых есть аппаратная поддержка atomic
специальными командами в микроконтроллерах</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Контроль размера стека</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Да</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Поддержка RTOS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Да</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Статический анализатор кода с набором правил</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Да - MISRAC++2008, SECURITY,CERT, STDCHECKS</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Динамический анализ кода</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">C-RUN</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сертификация и проверка соответствию стандартам безопасности</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сертификация на безопасность по стандартам IEC 61508 и ISO 26262 экспертной организацией TUV SUD – SIL3 сертификат</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Поддержка микроконтроллера STM32F411 RE</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Полная</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_вопросы_по_разделу">6.6. Вопросы по разделу</h3>
<div id="__asciidoctor-preview-83__" class="qlist qanda">
<ol>
<li>
<p><em>Дайте определение понятию “Интегрированной среде разработки”</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Что такое компилятор и чем он отличается от транслятора?</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Что такое компоновщик и какие функции он выполняет?</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Почему важен процесс проектирования ПО какие задачи входят в этот процесс?</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Дорисуйте процесс разработки ПО <a href="#IAR Workbench">[IAR Workbench]</a> с учетом итеративности связей в этом процессе</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Зачем нужная отладка и в каких случаях она применяется? Для чего применяются точки остановки?</em></p>
<p>Ответ:</p>
</li>
<li>
<p><em>Какие еще важные IAR workbench можно добавить в таблицу <a href="#Характеристики IAR">[Характеристики IAR]</a></em></p>
<p>Ответ:</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_программного_обеспечения_2">6.7. Запуск программного обеспечения</h3>
<div class="sect3">
<h4 id="_файл_cstartup_cpp">6.7.1. Файл cstartup.cpp</h4>
<div id="__asciidoctor-preview-98__" class="paragraph">
<p>Действия по инициализации прописываются в файле cstartup. Этот файл может быть написан как на
ассемблере, на Си, так и на С+. Поскольку мы будем использовать С+, то и файл будем использовать
cstartup.cpp, который будет выглядеть примерно так</p>
</div>
<div id="__asciidoctor-preview-99__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c" class="language-c hljs">extern "C" void __iar_program_start(void) ;

class InterruptHandler {
  public:
    static void DummyHandler() { for(;;) {} }
    }
};

using tIntFunct = void(*)();
using tIntVectItem = union {tIntFunct __fun; void * __ptr;};
#pragma segment = "CSTACK"
#pragma location = ".intvec"
const tIntVectItem __vector_table[] = {
  { .__ptr = __sfe( "CSTACK" ) }, //инициализация стека
    __iar_program_start, //переход на адрес функции __iar_program_start

  InterruptHandler::DummyHandler,
  ...
  InterruptHandler::DummyHandler,        ////TIM4
};

extern "C" void __cmain(void) ;
extern "C" __weak void __iar_init_core(void) ;
extern "C" __weak void __iar_init_vfp(void) ;

#pragma required = __vector_table
void __iar_program_start(void) {
  __iar_init_core() ;
  __iar_init_vfp() ;
  __cmain() ;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-100__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-101__" class="paragraph">
<p>Немного проясним, что здесь написано, строка:</p>
</div>
<div id="__asciidoctor-preview-102__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c" class="language-c hljs">extern "C" void __iar_program_start( void );</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-103__" class="paragraph">
<p>Описывает прототип функции __iar_program_start, которая будет отвечать за инициализацию переменных
и запуск функции main(). Реализацию этой функции вы можете увидеть в самом конце файла cstarup.cpp</p>
</div>
<div id="__asciidoctor-preview-104__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c" class="language-c hljs">void __iar_program_start( void ) {
__iar_init_core();
__iar_init_vfp();
__cmain();
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-105__" class="paragraph">
<p>Далее идет определение класса с описание одного единственного метода handler(). Это метод и будет
тем самым обработчиком прерывания который вызовется при срабатывании соответствующего прерывания.
Реализация метода проста – бесконечный цикл, т.е. попав в прерывание программа “навсегда” останется
в нем:</p>
</div>
<div id="__asciidoctor-preview-106__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">__weak void DummyModule::handler()   { for(;;) {} };</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-107__" class="paragraph">
<p>Это сделано для того, что пока не планируем использвать никаких прерываний, и если все таки каким то
образом прерывание сработало, значит, что-то было сделано не так.  В дальнейшем в разделе
<a href="#Прерывания">[Прерывания]</a> будет показано, как сделать нужный нам обработчик прерывания, но сейчас мы не будем
на этом заострять внимание. Следующий две строки определяют новый тип, который будет использоваться
для задания элементов таблицы векторов прерываний:</p>
</div>
<div id="__asciidoctor-preview-108__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">typedef void( *intfunc )( void );
typedef union { intfunc __fun; void * __ptr; } intvec_elem;</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-109__" class="paragraph">
<p>Как видно этот тип есть объединение двух типов, указателя на функцию типа void и указателя на void.
Это необходимо для того, чтобы правильно интерпретировать элементы таблицы. Ведь начальный вектор
прерывания не содержит никакого обработчика, а просто содержит конечный адрес стека, а последующие
вектора содержат адреса обработчиков, именно поэтому первый элемент таблицы векторов должен иметь
тип указателя на void, а последующие указателей на функцию типа void.
Собственно далее идет и сама таблица лежащая в выделенном для неё сегменте .intvec, который задается в настройках линковщика
#pragma location = ".intvec"
Таблица начинается с адреса стека, который также задается сегментом CSTACK в настройке линковщика, а следующий элемент таблицы есть адрес функции инициализации переменных, а затем адреса обработчиков для конкретных прерываний.</p>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_использование_с">7. Использование С++</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-110__" class="ulist">
<ul>
<li id="__asciidoctor-preview-111__">
<p>Так же как когда-то Си пробивал себе дорогу в качестве стандарта для встроенного ПО, так и язык С++
уже вполне может заменить Си в этой области.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-112__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-113__" class="paragraph">
<p>Язык программирования стандарта С+ + и современные компиляторы имеют достаточно средств для того
чтобы создавать компактный код и не уступать по эффективности коду, созданному на Си, а благодаря
нововведениям быть понятнее и надежнее.. Начиная с версии IAR
Workbench 8.40 компилятор поддерживает полезные нововведения стандарта С++17, такие, как например
“структурные привязки”,  “инициализация в ветвлениях”, “встроенные переменные”.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-114__" class="ulist">
<ul>
<li id="__asciidoctor-preview-115__">
<p>С++ является строго типизированным языком, а значит программы написанные на нем более безопасны, чем
программы написанные на Си и меньше вероятность того, что программист допустит ошибку.</p>
</li>
<li id="__asciidoctor-preview-116__">
<p>С++ является языком программирования полностью поддерживающий парадигму программирования ООП,
которая отлично подходит для разработки программного обеспечения измерительных устройств.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-117__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-118__" class="paragraph">
<p>Ведь нужно понимать, что для измерительного устройства нам нужно описать логику работы, интерфейс
взаимодействия с пользователем, реализовать расчеты, а не помнить, что для того чтобы считать
данные с АЦП, нужно вначале его выбрать с помощью сигнала CS, находящегося на порту GPIOA.3 и
установить его в единицу. Этим должен заниматься разработчик драйверов.</p>
</div>
<div id="__asciidoctor-preview-119__" class="paragraph">
<p>Большинство драйверов для работы с аппаратурой уже реализованы производителями микроконтроллеров,
например, в библиотеках CMSIS и CMSIS_HAL, ими можно воспользоваться для обращения к функциям
доступа к аппаратуре, упростить и ускорить разработку.</p>
</div>
<div id="__asciidoctor-preview-120__" class="paragraph">
<p>Замечаниями по этому поводу может служить то, что эти библиотеки довольно громоздкие и для
использования в небольших приложениях вряд ли подойдут, кроме того, не всегда они имеют необходимые
сертификаты надежности, а потому при разработке реальных измерительных устройств, применение которых
планируется в местах с повышенной безопасностью промышленных предприятиях, вряд ли стоит
пользоваться этими библиотеками.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-121__" class="paragraph">
<p>Именно поэтому, мы будет использовать С++ от написания драйверов и уровня аппаратуры и до реализации
логики работы с пользователем. Начнем же изучение с создания проекта, системы тактирования и
небольшой программы мигания светодиодом.</p>
</div>
<div class="sect2">
<h3 id="_программа_на_с">7.1. Программа на С++</h3>
<div id="__asciidoctor-preview-122__" class="paragraph">
<p>Как было сказано в разделе <a href="#_состав_интеграционной_среды_разработки_iar_workbench">Состав интеграционной среды разработки IAR Workbench</a>
первоначально мы должны создать исходные файлы на языке программирования С.
В С разделяют два типа файлов:</p>
</div>
<div id="__asciidoctor-preview-123__" class="ulist">
<ul>
<li id="__asciidoctor-preview-124__">
<p>Исходный файл (файл с раширением *.cpp)</p>
</li>
<li id="__asciidoctor-preview-125__">
<p>Заголовочный файл (файл с расширением *.h, *.hpp)</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-126__" class="paragraph">
<p>Загловочные файлы подключаются с помощью директивы #include и при трансляции
просто вставляются в текст *.cpp файла. Используются они для того, чтобы вынести
общие определения, испольжуемые в нескольких *.cpp файлах в одно место.</p>
</div>
<div id="__asciidoctor-preview-127__" class="listingblock">
<div class="title">Вот так может выглядеть ваша программа:</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">#include "gpioaregisters.hpp" //for Gpioa
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOAEN::Enable::Set() ;
  GPIOA::MODER::MODER15::Output::Set() ;
  GPIOA::ODR::ODR15::Enable::Set() ;
  return 0 ;
}</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_создание_проекта_и_работа_в_iar_workbench">8. Создание проекта и работа в IAR Workbench</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-128__" class="ulist">
<ul>
<li id="__asciidoctor-preview-129__">
<p>Создать новый проект Project&#8658;Create New Project.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-130__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure9.png" alt="400" width="400">
</div>
<div class="title">Рисунок 9. Создание нового проекта</div>
</div>
<div class="sect2">
<h3 id="_выбор_шаблона_проекта">8.1. Выбор шаблона проекта</h3>
<div id="__asciidoctor-preview-131__" class="ulist">
<ul>
<li id="__asciidoctor-preview-132__">
<p>Выбирать шаблон проекта( ProjectTemplates): C++ - main</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-133__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure10.png" alt="400" width="400">
</div>
<div class="title">Рисунок 10. Выбор шаблона проекта</div>
</div>
</div>
<div class="sect2">
<h3 id="_выбор_микроконтроллера">8.2. Выбор микроконтроллера</h3>
<div id="__asciidoctor-preview-134__" class="ulist">
<ul>
<li id="__asciidoctor-preview-135__">
<p>Сохранить проект под каким-либо именем</p>
</li>
<li id="__asciidoctor-preview-136__">
<p>В свойствах проекта выбрать модель микроконтроллера ST &#8658; STM32F4&#8658; STM32F411&#8658; ST STM32F411RE см.
<a href="#_выбор_микроконтроллера">Выбор микроконтроллера</a>. Для этого правой кнопкой мыши щелкнуть по проекту, выбирать Options
и далее в категории General Option выбрать закладку Target.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-137__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure11.png" alt="500" width="500">
</div>
<div class="title">Рисунок 11. Выбор микроконтроллера</div>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_в_режиме_отладки">8.3. Запуск в режиме отладки</h3>
<div id="__asciidoctor-preview-138__" class="paragraph">
<p>После создания проекта необходимо сохранить так называемое рабочее пространство или (workspace).</p>
</div>
<div id="__asciidoctor-preview-139__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-140__" class="paragraph">
<p>В рабочее пространство можно загружать несколько проектов (например, проекты всех лабораторных работ)
и переключаться между проектами по мере необходимости.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-141__" class="paragraph">
<p>После того, как проект сделан, и имеет вид показанный на <a href="#Вид созданного проекта">[Вид созданного проекта]</a>, можно
попробовать собрать проект, нажав кнопку Ctrl-F7, а затем загрузить полученный бинарный файл в
микропроцессор и запустить на отладку с помощью кнопки Ctrl-D.</p>
</div>
<div id="__asciidoctor-preview-142__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-143__" class="paragraph">
<p>Все тоже самое можно сделать и с помощью кнопок быстрого доступа на панели инструментов, через меню
среды или контекстное меню проекта (загрузить которое можно нажав на правую клавишу мыши на проекте).</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-144__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure12.png" alt="500" width="500">
</div>
<div class="title">Рисунок 12. Вид созданного проекта</div>
</div>
</div>
<div class="sect2">
<h3 id="_запуск_проекта_в_режим_симуляции">8.4. Запуск проекта в режим симуляции</h3>
<div id="__asciidoctor-preview-145__" class="paragraph">
<p>По умолчанию загрузка и отладка бинарного файла осуществляется в симулятор выбранного
микроконтроллера. Поэтому, если вы выполнили все верно, то должно получиться нечто похожее,
показанное на <a href="#Проект в режиме отладки">[Проект в режиме отладки]</a>.</p>
</div>
<div id="__asciidoctor-preview-146__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure13.png" alt="500" width="500">
</div>
<div class="title">Рисунок 13. Проект в режиме отладки</div>
</div>
<div id="__asciidoctor-preview-147__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-148__" class="paragraph">
<p>На этом рисунке вы можете видеть, как сам ваш код написанный на С++, так и окно дизассемблера,
показывающее как компилятор преобразовал ваш код в команды ассемблера. Зеленая строчка показывает
текущую исполняющую строчку вашего кода и команду ассемблера.</p>
</div>
<div id="__asciidoctor-preview-149__" class="paragraph">
<p>Для того чтобы остановить отладку и выйти в режим разработки необходимо нажать кнопки Ctrl-Shift-D.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_выбор_внутрисхемного_отладчика">8.5. Выбор внутрисхемного отладчика</h3>
<div id="__asciidoctor-preview-150__" class="paragraph">
<p>Чтобы загрузить программу в микроконтроллер необходимо вместо симулятора выбрать внутрисхемный
отладчик, которым вы пользуетесь. Это можно сделать, встав на проект и нажать на правую кнопку мыши,
далее выбрать пункт меню Options&#8658;Debugger&#8658;Driver и выбрать в нем нужный вам внутрисхемный отладчик,
см <a href="#_выбор_внутрисхемного_отладчика">Выбор внутрисхемного отладчика</a>. Мы будет использовать отладчик ST-Link.</p>
</div>
<div id="__asciidoctor-preview-151__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure14.png" alt="450" width="450">
</div>
<div class="title">Рисунок 14. Выбор внутрисхемного отладчика</div>
</div>
<div id="__asciidoctor-preview-152__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-153__" class="paragraph">
<p>Теперь, если вы нажмете Ctrl-D, ваша программа загрузиться в микроконтроллер и отладка будет
осуществляться непосредственно на ядре микроконтроллера.
И так вы смогли сделать проект, откомпилировать пустую программу и загрузить её в симулятор и
микроконтроллер, но всех этих действий недостаточно, для того, чтобы начать разрабатывать
программное обеспечение. Рассмотрим, что же еще необходимо сделать для того, чтобы наш проект был
полностью готов.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_структура_проекта">9. Структура проекта</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-154__" class="paragraph">
<p>Для того, чтобы разработка была быстрой и качественной, необходимо структурировать паку проекта.</p>
</div>
<div id="__asciidoctor-preview-155__" class="ulist">
<ul>
<li id="__asciidoctor-preview-156__">
<p>Не нужно писать весь код в одном файле. Лучше каждый класс описывать в отдельном файле</p>
</li>
<li id="__asciidoctor-preview-157__">
<p>Файлы с классами, ответственные за один компонент, лучше держать в папках с именем этого компонента</p>
</li>
<li id="__asciidoctor-preview-158__">
<p>Не превращаем проект в мусорку</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_добавление_файла_cstartup_cpp_в_проект">9.1. Добавление файла (cstartup.cpp) в проект</h3>
<div id="__asciidoctor-preview-159__" class="paragraph">
<p>В папку где вы сохранили проекта, необходимо скопировать файл cstartup.cpp. и добавить его к проекту:
Для этого нужно нажать правую кнопку мыши на проекте и выбрав пункт Add&#8658;Add Files… как показано на
<a href="#Добавление нового файла в проект">[Добавление нового файла в проект]</a>, а затем выбрать файл startup_stm32F411.cpp.</p>
</div>
<div id="__asciidoctor-preview-160__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure15.png" alt="450" width="450">
</div>
<div class="title">Рисунок 15. Добавление нового файла в проект</div>
</div>
<div id="__asciidoctor-preview-161__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-162__" class="paragraph">
<p>Как было сказано выше, в файле cstartup.cpp описывается таблица вектров прерываний и начальная
инициализация. Поэтому первым делоам нужно подкючить файал cstartuo.cpp в проект. Тут следует иметь
ввиду, что таблица векторов прерываний для разных микроконтроллеров разная, и соответственно файлы
cstartup должен быть различных для разных микроконтроллеров. Чтобы не перепутать свой файлы для
разных микроконтроллеров, назовем его startup_stm32F411.cpp и подключим к проекту, нажав правую
кнопку мыши на проекте и выбрав пункт Add&#8658;Add Files… (см. Рисунок 21 ), а затем выбрав файл
startup_stm32F411.cpp.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_начальная_структура_проекта">9.2. Начальная структура проекта</h3>
<div id="__asciidoctor-preview-163__" class="paragraph">
<p>Добавив файл в проект у вас должно получиться следующая структура в среде IAR Workbench:</p>
</div>
<div id="__asciidoctor-preview-164__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure16.png" alt="400" width="400">
</div>
<div class="title">Рисунок 16. Начальная структура проекта</div>
</div>
</div>
<div class="sect2">
<h3 id="_доступ_к_папке_проекта">9.3. Доступ к папке проекта</h3>
<div id="__asciidoctor-preview-165__" class="paragraph">
<p>Теперь нужно разобраться с тем как будет организован наш проект на диске и в системе контроля
версий. Если мы нажмем правой мышкой на проекте и выберем пункт Open Containing Folder см.
<a href="#Открытие папки проекта">[Открытие папки проекта]</a>, то мы попадем в папку нашего проекта.</p>
</div>
<div id="__asciidoctor-preview-166__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure17.png" alt="250" width="250">
</div>
<div class="title">Рисунок 17. Открытие папки проекта</div>
</div>
<div id="__asciidoctor-preview-167__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-168__" class="paragraph">
<p>Мы увидим что у нас есть папки Debug и Settings, а также созданные нами файлы проекта, файлы рабочей
области, main.cpp и startup_stm32F411.cpp. В паке Debug хранятся объектные файлы, двоичные файлы для
прошивки, листинг программы, созданные в режиме Debug (т.е. в режиме, когда в программу добавляется
некая служебная информация и функциональность для того, чтобы можно было поддерживать внутрисхемную
отладку. Существует также режим Release, когда двоичный файл содержит только код программы).</p>
</div>
<div id="__asciidoctor-preview-169__" class="paragraph">
<p>В папке Settings хранятся настройки проекта и рабочей области.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_cтруктура_папки_проекта">9.4. Cтруктура папки проекта</h3>
<div id="__asciidoctor-preview-170__" class="paragraph">
<p>⦁ Нам нужна будет папка AbstractHardware/Registers. В которой находятся файлы с описанием полей
регистров. Можно скопировать ее путем клонирования папки проекта преподавателя, набрав в командной
сстроке:</p>
</div>
<div id="__asciidoctor-preview-171__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">git clone https://github.com/lamer0k/CortexLib.git</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-172__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-173__" class="paragraph">
<p>Вы можете скопировать папку преподавателя через Git, используя PowerShell. Для этого, нужно нажав на
вашу папку правой кнопкой мыши, удерживая Shift, выбрать меню "Открыть окно PowerShell здесь".</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-174__" class="paragraph">
<p>⦁ В папке AbsstractHardware будут содержаться файлы для работы с регистрами, аппаратурой и периферией.</p>
</div>
<div id="__asciidoctor-preview-175__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-176__" class="paragraph">
<p>Папка AbstractHardware содержит зависимую от микроконтроллера часть.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-177__" class="paragraph">
<p>⦁ Дополнительно создадим еще папку Application, в которой в дальнейшем будут содержаться файлы классов
для работы с логикой программы.</p>
</div>
<div id="__asciidoctor-preview-178__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-179__" class="paragraph">
<p>Папка Application будет содержать полностью независимую часть, которую можно будет перенести на
любую другую платформу и микроконтроллер. А папка AbstractHardware будет содержать модули зависящие
от конкретного микроконтроллера.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-180__" class="paragraph">
<p>⦁ В завершение добавим папку FreeRtos – она пригодиться нам при работе с ОСРВ.</p>
</div>
<div id="__asciidoctor-preview-181__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure18.png" alt="350" width="350">
</div>
<div class="title">Рисунок 18. Финальное содержимое папки проекта</div>
</div>
</div>
<div class="sect2">
<h3 id="_изменение_структуры_проекта">9.5. Изменение структуры проекта</h3>
<div id="__asciidoctor-preview-182__" class="paragraph">
<p>Теперь необходимо создать точно такую же структуру в проекте IAR Workbench, как и структура папок.
Для этого необходимо нажать правой мышкой на проект, и выбрать меню Add&#8658;Ggroup и создать группы
Abstract_Hardware, Application, Common, FreeRtos.</p>
</div>
<div id="__asciidoctor-preview-183__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure19.png" alt="400" width="400">
</div>
<div class="title">Рисунок 19. Изменение структуры проекта</div>
</div>
</div>
<div class="sect2">
<h3 id="_финальная_структура_проекта">9.6. Финальная структура проекта</h3>
<div id="__asciidoctor-preview-184__" class="paragraph">
<p>В конечном итоге у вас должна появиться вот такая структура:</p>
</div>
<div id="__asciidoctor-preview-185__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure20.png" alt="400" width="400">
</div>
<div class="title">Рисунок 20. Финальная структура проекта</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_окончательная_настройка_проекта">10. Окончательная настройка проекта</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-186__" class="paragraph">
<p>Для окончательной настройки проекта, нам понадобится настроить компоновщик и установить размер
сегментов памяти, стека и кучи.</p>
</div>
<div id="__asciidoctor-preview-187__" class="paragraph">
<p>Перед тем как производить их настройку разберемся, что такое сегменты памяти, стек и куча и для чего
они нужны.</p>
</div>
<div class="sect2">
<h3 id="_организация_памяти">10.1. Организация памяти</h3>
<div id="__asciidoctor-preview-188__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-189__" class="paragraph">
<p>Существует несколько признанных архитектур микропроцессоров
 * Архитектура ФонНеймана
 * Гарвардская архитектура
В традиционных микропроцессорах используется архитектура Фон Неймана (названную так в честь
американского математика Джона Фон Неймана), см. <a href="#Архитектуры микропроцессоров">[Архитектуры микропроцессоров]</a> A.</p>
</div>
<div id="__asciidoctor-preview-190__" class="paragraph">
<p>Эта архитектура состоит из единого блока памяти, в котором хранятся и команды, и данные, и общей
шины для передачи данных и команд в ЦПУ и от него. При такой архитектуре перемножение двухчисел
требует по меньшей мере трех циклов: двух циклов для передачи двух чисел в ЦПУ, и одного – для
передачи команды. Данная архитектура приемлема в том случае, когда все действия могут выполняться
последовательно. По сути говоря, в большинстве компьютеров общего назначения используется сегодня
такая архитектура.</p>
</div>
<div id="__asciidoctor-preview-191__" class="paragraph">
<p>Однако для быстрой обработки сигналов больше подходит гарвардская архитектура, см <a href="#Архитектуры микропроцессоров">[Архитектуры микропроцессоров]</a>B.
Данная архитектура получила свое название в связи с работами, проведенными в Гарвардском университете
под руководством Ховарда Айкена. Данные и код программы хранятся в различных блоках памяти и доступ
к ним осуществляется через разные шины, как показано на схеме. Т.к. шины работают независимо, выбор
команд программы и данных может осуществляться одновременно, повышая таким образом скорость по
сравнению со случаем и спользования одной шины вархитектуре Фон Неймана.</p>
</div>
<div id="__asciidoctor-preview-192__" class="paragraph">
<p>На <a href="#Архитектуры микропроцессоров">[Архитектуры микропроцессоров]</a>C, представлена модифицированная гарвардская архитектура, где и
команды, и данные могут храниться в памяти программ.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-193__" class="paragraph">
<p>ARM  является модифицированной гарвардской архитектурой.</p>
</div>
<div id="__asciidoctor-preview-194__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure22.png" alt="800" width="800">
</div>
<div class="title">Рисунок 21. Архитектуры микропроцессоров</div>
</div>
<div id="__asciidoctor-preview-195__" class="paragraph">
<p>Доступ к памяти осуществляется по одной шине, а уже устройство управления памятью обеспечивает
разделение шин при помощи управляющих сигналов: чтения, записи или выбора области памяти.</p>
</div>
<div id="__asciidoctor-preview-196__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-197__" class="paragraph">
<p>Данные и код могут находится в одной и той же области памяти. В этом едином адресном пространстве
может находится и ПЗУ и ОЗУ и периферия. А это означает, что собственно и код и данные могут попасть
хоть куда(в ОЗУ или в ПЗУ) и это зависит только от компилятора и линкера.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_настройка_области_памяти_в_комповшике">10.2. Настройка области памяти в комповшике</h3>
<div id="__asciidoctor-preview-198__" class="paragraph">
<p>Поэтому чтобы различить области памяти для ПЗУ(ROM) и ОЗУ их обычно указывают в настройках линкера.</p>
</div>
<div id="__asciidoctor-preview-199__" class="listingblock">
<div class="title">В настройках линкера IAR 8.40.1 это выглядит вот так:</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;
define symbol __ICFEDIT_region_ROM_end__   = 0x0807FFFF;
define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;
define symbol __ICFEDIT_region_RAM_end__   = 0x2001FFFF;
define region ROM_region   = mem:[from __ICFEDIT_region_ROM_start__  to __ICFEDIT_region_ROM_end__];
define region RAM_region   = mem:[from __ICFEDIT_region_RAM_start__  to __ICFEDIT_region_RAM_end__];</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-200__" class="paragraph">
<p>В данном микроконтроллере диапазон адресом для памяти слудющий:</p>
</div>
<div id="__asciidoctor-preview-201__" class="ulist">
<ul>
<li id="__asciidoctor-preview-202__">
<p>ОЗУ(RAM) 0x20000000&#8230;&#8203;0х2001FFF,</p>
</li>
<li id="__asciidoctor-preview-203__">
<p>ПЗУ(ROM) с 0x008000000&#8230;&#8203;0x0807FFFF.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-204__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-205__" class="paragraph">
<p>Вы легко можете поменять начальный адрес ROM_start на адрес ОЗУ, скажем RAM_start и конечный адрес
ROM_end<em> на адрес RAM_end</em> и ваша программа будет полностью расположена в ОЗУ.</p>
</div>
<div id="__asciidoctor-preview-206__" class="paragraph">
<p>Вы даже можете сделать наоборот и указать ОЗУ в области памяти ROM, и ваша программа успешно
соберется и прошьется, правда работать не будет :)</p>
</div>
<div id="__asciidoctor-preview-207__" class="paragraph">
<p>Некоторые микроконтроллеры, такие как, AVR изначально имеют раздельное адресное пространство для
памяти программ, памяти данных и периферии и потому там такие фокусы не пройдут, а программа по
умолчанию записывается в ROM память.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-208__" class="listingblock">
<div class="title">Важно</div>
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Все адресное пространство в CortexM единое, и код и данные могут размещаться где угодно. С помощью
настроек линкера можно задать регион для адресов ПЗУ(ROM) и ОЗУ(RAM) памяти. IAR располагает сегмент
кода .text в регионе ROM памяти.</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_объектный_файл_и_сегменты">10.3. Объектный файл и сегменты</h3>
<div id="__asciidoctor-preview-209__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-210__" class="paragraph">
<p>Выше я упомянул про сегмент кода, давайте разберемся, что это такое.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-211__" class="paragraph">
<p>На каждый компилируемый модуль создается отдельный объектный файл, который содержит следующую информацию:</p>
</div>
<div id="__asciidoctor-preview-212__" class="ulist">
<ul>
<li id="__asciidoctor-preview-213__">
<p>Сегменты кода и данных</p>
</li>
<li id="__asciidoctor-preview-214__">
<p>Отладочную информацию в формате DWARF</p>
</li>
<li id="__asciidoctor-preview-215__">
<p>Таблицу символов</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-216__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-217__" class="paragraph">
<p>Нас интересуют сегменты кода и данных.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-218__" class="paragraph">
<p>Сегмент это такой элемент, содержащий часть кода или данных, который должен быть помещен по
физическому адресу в памяти. Сегмент может содержать несколько фрагментов, обычно один фрагмент на
каждую переменную или функцию. Сегмент может быть помещен как в ПЗУ(ROM) так и ОЗУ(RAM).</p>
</div>
<div id="__asciidoctor-preview-219__" class="paragraph">
<p>В общем и целом, сегмент это наименьший линкуемый блок.</p>
</div>
</div>
<div class="sect2">
<h3 id="_атрибуты_сегментов">10.4. Атрибуты сегментов</h3>
<div id="__asciidoctor-preview-220__" class="paragraph">
<p>Каждый сегмент имеет имя и атрибут, который определяет его содержимое. Атрибут используется для
определения сегмента в конфигурации для линкера. Например, атрибуты могут быть:
* code — исполняемый код
* readonly — константные переменные
* readwrite — инициализируемые переменные
* zeroinit — инициализируемые нулем переменные</p>
</div>
<div id="__asciidoctor-preview-221__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-222__" class="paragraph">
<p>Конечно есть и другие типы сегментов, например сегменты, содержащие отладочную информацию, но нас
будут интересовать только те, которые содержат код или данные нашего приложения.</p>
</div>
<div id="__asciidoctor-preview-223__" class="paragraph">
<p>Повторюсь, сегмент это наименьший линкуемый блок. Однако при необходимости линкеру можно указать и
еще более мелкие блоки(фрагменты). Этот вариант рассматривать не будем, остановимся на сегментах.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_предопределенные_имена_сегментов_в_iar_workbench">10.5. Предопределенные имена сегментов в IAR Workbench</h3>
<div id="__asciidoctor-preview-224__" class="paragraph">
<p>Во время компиляции данные и функции размещаются в различные сегменты. А во время линковки, линкер
назначает им реальные физические адреса. В компиляторе IAR есть предопределенные имена сегментов,
некоторые из них приведены ниже:</p>
</div>
<div id="__asciidoctor-preview-225__" class="ulist">
<ul>
<li id="__asciidoctor-preview-226__">
<p>.bss — Содержит статические и глобальные переменные инициализируемые 0</p>
</li>
<li id="__asciidoctor-preview-227__">
<p>.CSTACK — Содержит стек используемый программой</p>
</li>
<li id="__asciidoctor-preview-228__">
<p>.data — Содержит статические и глобальные инициализируемые переменные</p>
</li>
<li id="__asciidoctor-preview-229__">
<p>.data_init — Содержит начальные значения для данных в .data секции, если используется директива
инициализации для линкера</p>
</li>
<li id="__asciidoctor-preview-230__">
<p>HEAP — Содержит кучу, используемую для размещения динамических данных</p>
</li>
<li id="__asciidoctor-preview-231__">
<p>.intvec — Содержит таблицу векторов прерываний</p>
</li>
<li id="__asciidoctor-preview-232__">
<p>.rodata — Содержит константные данные</p>
</li>
<li id="__asciidoctor-preview-233__">
<p>.text — Содержит код программы</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-234__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-235__" class="paragraph">
<p>На практике это означает, что если вы определили переменную int val = 3, то сама переменная будет
расположена компилятором в сегмент .data и помечена атрибутом readwrite, а число 3 может быть
помещено либо в сегмент .text, либо в сегмент .rodata или, если применена специальная директива для
линкера в .data_init и также помечается им как readonly.</p>
</div>
<div id="__asciidoctor-preview-236__" class="paragraph">
<p>Сегмент .rodata содержит константные данные и включает в себя константные переменные, строки,
агрегатные литералы и так далее. И этот сегмент может быть размещена где угодно в памяти.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_файл_настройки_компоновщика">10.6. Файл настройки компоновщика</h3>
<div id="__asciidoctor-preview-237__" class="paragraph">
<p>Файл линкера имеет расширение*.icf. В нащем проекте этот файл называется stm32f411xE.icf. Давайте
теперь поймем, что же прописано в настройках линкера и почему.</p>
</div>
<div id="__asciidoctor-preview-238__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">define symbol __ICFEDIT_region_ROM_start__ = 0x08000000;
define symbol __ICFEDIT_region_ROM_end__   = 0x0807FFFF;
define symbol __ICFEDIT_region_RAM_start__ = 0x20000000;
define symbol __ICFEDIT_region_RAM_end__   = 0x2001FFFF;
define region ROM_region   = mem:[from __ICFEDIT_region_ROM_start__  to __ICFEDIT_region_ROM_end__];
define region RAM_region   = mem:[from __ICFEDIT_region_RAM_start__  to __ICFEDIT_region_RAM_end__];

// Разместить  сегменты .rodata и .data_init (константы и   инициализаторы) в (ПЗУ)ROM:

place in ROM_region   { readonly };

// Разместить сегменты .data, .bss, .noinit, STACK  и HEAP в (ОЗУ)RAM

place in RAM_region   { readwrite, block STACK , block HEAP };</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_настройка_стека">11. Настройка стека</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_стек">11.1. Стек</h3>
<div id="__asciidoctor-preview-239__" class="paragraph">
<p>Для начала определение из Википедии:</p>
</div>
<div id="__asciidoctor-preview-240__" class="paragraph">
<p>Стек (англ. Stack - стопка; читается стэк) - абстрактный тип данных, представляющий собой список
элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым
вышел»).</p>
</div>
<div id="__asciidoctor-preview-241__" class="paragraph">
<p>В стек можно положить данные, и можно данные забрать, причем те данные которые были положены в стек
последним, забираем из стека первым</p>
</div>
<div id="__asciidoctor-preview-242__" class="paragraph">
<p>Стек – это организация памяти, выполненная компоновщиком. На уровне микроконтроллера для работы со
стеком есть специальные ассемблерные команды (например PUSH – положить регистры в стек, и POP –
взять из стека). Так же для сохранения и считывания данных из стека могут использоваться
инструкции STR и LDR</p>
</div>
<div id="__asciidoctor-preview-243__" class="paragraph">
<p>Обычно в стеке сохраняются регистры когда вы вызываете подпрограмму, или проваливаетесь в прерывание,
для того, чтобы когда вернуться обратно в вашу программу восстановить весь контекст и все переменные.
Кроме того, если в вашей функции передается слишком много переменных и под все не хватит регистров,
то компилятор расположит их также на стеке. Локальные переменные функции также создаются на стеке.</p>
</div>
<div id="__asciidoctor-preview-244__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-245__" class="paragraph">
<p>В традиционной реализации память для всех локальных переменных функции выделяется сразу, одним
"кадром стека" в начале работы функции. Внутри этого кадра стека компилятор еще на стадии компиляции
разработает некую фиксированную карту расположения локальных переменных. При этом он может (и будет)
располагать локальные переменные в этой карте совершенно произвольным образом, руководствуясь
оптимизационными соображениями выравнивания, экономии памяти и т.д. и т.п.</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_правила_задания_размера_стека">11.2. Правила задания размера стека</h3>
<div id="__asciidoctor-preview-246__" class="paragraph">
<p>В большинстве "традиционных" платформ стек растет сверху-вниз: от старших адресов к младшим.
Поэтому прежде всего нужно верно указать размер или вершину стека. Для того, чтобы сделать это есть
пара правил:</p>
</div>
<div id="__asciidoctor-preview-247__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-248__">
<p>Всегда считаем, что все локальные переменные создаются на стеке (Хотя часть из них могут быть
созданы и на регистрах)</p>
</li>
<li id="__asciidoctor-preview-249__">
<p>У нас 16 регистров + регистры блока с плавающей точкой. Которые должны быть сохранены на стеке</p>
</li>
<li id="__asciidoctor-preview-250__">
<p>Каждая вложенная подпрограмма должна сохранить на стеке все данные из пункта 1 и 2. Т.е. если
вложенность будет 2, то и сохранять придется примерно в два раза больше данных</p>
</li>
<li id="__asciidoctor-preview-251__">
<p>Каждое прерывание должно сохранить данные из пункта 1 и 2.</p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_установка_размера_стека">11.3. Установка размера стека</h3>
<div id="__asciidoctor-preview-252__" class="paragraph">
<p>Обычно размер стека вычисляется эмпирически и задается с небольшим запасом.</p>
</div>
<div id="__asciidoctor-preview-253__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-254__" class="paragraph">
<p>Чтобы задать размер стека, нужно нажав на правую кнопку мыши на проекте, выбрать Option&#8658;Linker и
нажать кнопку Edit, далее выбрать закладку Stack/Heap Size, см. <a href="#Установка размера стека и кучи">[Установка размера стека и кучи]</a></p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-255__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure23.png" alt="500" width="500">
</div>
<div class="title">Рисунок 22. Установка размера стека и кучи</div>
</div>
<div id="__asciidoctor-preview-256__" class="paragraph">
<p>Тоже самое можно сделать руками в файле stm32f411xE.icf, поменяв значение символа <em>__ICFEDIT_size_cstack</em></p>
</div>
</div>
<div class="sect2">
<h3 id="_контроль_за_размер_стеком">11.4. Контроль за размер стеком</h3>
<div id="__asciidoctor-preview-257__" class="paragraph">
<p>IAR Workbench имеет встроенные средства для контроля стека на этапе сборки он может указать
максимально возможный размер стека для вашего приложения для самой глубокой цепочки вызова функций.</p>
</div>
<div id="__asciidoctor-preview-258__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-259__" class="paragraph">
<p>Это значение можно использовать как ориентир при установке максимального значения стека.
Однако следует помнить, что во-первых, в вашей программе возможно никогда не будет самой глубокой
цепочки вложенности, а во вторых не всегда компоновщик сможет определить верно размер, например,
при использовании ОСРВ, указатель стека постоянно изменяется и стек выделяется под каждую задачу
отдельно, в итоге вся программа может работать вообще без единого стека и его размер можно
минимальным. Зато придется указывать размер стека для каждой задачи при её создании. В любом случае,
очень полезно знать об этой особенности и как её задействовать.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-260__" class="paragraph">
<p>Для включения достаточно поставить галочку в меню Option&#8658;Linker&#8658;Advanced&#8658;Enable stack usage
analysis см. <a href="#Опция анализа глубины стека">[Опция анализа глубины стека]</a></p>
</div>
<div id="__asciidoctor-preview-261__" class="imageblock">
<div class="content">
<img src="Lection1Img/Figure24.png" alt="400" width="400">
</div>
<div class="title">Рисунок 23. Опция анализа глубины стека</div>
</div>
</div>
<div class="sect2">
<h3 id="_доступ_к_данным_по_анализу_размеру_стека">11.5. Доступ к данным по анализу размеру стека</h3>
<div id="__asciidoctor-preview-262__" class="paragraph">
<p>После установки этой опции на выходе компоновщика в файле с раcширением *.map можно будет увидеть
результат анализа, например, такой:</p>
</div>
<div id="__asciidoctor-preview-263__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">Call Graph Root Category  Max Use  Total Use
------------------------  ------ - -------- -
Program entry                896        896
Uncalled function              0          0

Program entry
"__iar_program_start": 0x08005291

Maximum call chain                              896  bytes

"__iar_program_start"                           8
"__cmain"                                       0
"main"                                         88
"std::ostream::operator &lt;&lt;(float)"             80
"std::numpunct&lt;char&gt;::grouping() const"         8
"std::numpunct&lt;char&gt;::do_grouping() const"      8
"std::string::basic_string(char const *)"      16
"std::string::assign(char const *)"            16
"std::string::assign(char const *, unsigned int)" 16
"std::string::assign(const std::string&amp;, unsigned int, unsigned int)" 32
"std::string::_Grow(unsigned int, bool)"        16
"std::string::_Copy(unsigned int, unsigned int)" 32</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-264__" class="paragraph">
<p>В данном случае анализ стека показывает, что размер стека при максимальной цепочке вложенности может
быть 896 байт.</p>
</div>
</div>
<div class="sect2">
<h3 id="_куча">11.6. Куча</h3>
<div id="__asciidoctor-preview-265__" class="paragraph">
<p>Куча  (англ. heap) - .структура данных с помощью которой организуется динамически распределение
памяти  приложения. Размер кучи — размер памяти, выделенной операционной системой (ОС) для хранения
кучи (под кучу).</p>
</div>
<div id="__asciidoctor-preview-266__" class="paragraph">
<p>Компоновщик выделяет раздел памяти под кучу в соответствии с заданным размером кучи, а при запуске
программы происходит инициализация кучи, в ходе которой память, выделенная под кучу, отмечается как
свободная.</p>
</div>
<div id="__asciidoctor-preview-267__" class="paragraph">
<p>Куча используется только при динамически выделяемой памяти, для нас это означает, что все объекты
созданные с помощью оператора new будут расположены в куче.</p>
</div>
<div id="__asciidoctor-preview-268__" class="paragraph">
<p>Механизм выделения памяти описывать не будем, просто нужно запомнить, что если объект создан с
помощью оператора new, то все его содержимое хранится в куче.</p>
</div>
<div id="__asciidoctor-preview-269__" class="paragraph">
<p>Я не советую использовать динамическое создание объектов. Так как динамческое выделение памяти не
рекомендуется для использования в надежном ПО. Лучше делать все объекты статическими.</p>
</div>
</div>
<div class="sect2">
<h3 id="_определение_размера_кучи">11.7. Определение размера кучи</h3>
<div id="__asciidoctor-preview-270__" class="paragraph">
<p>Как определить размер кучи, необходимой под кучу. Можно вооружиться несколькими правилами:</p>
</div>
<div id="__asciidoctor-preview-271__" class="ulist">
<ul>
<li id="__asciidoctor-preview-272__">
<p>Чтобы узнать размер объекта в куче, можно воспользоваться оператором sizeof, который может вернуть
вам размер в байтах типа объекта (собственно, он будет равен размеру объекта расположенному в куче).
Таким образом узнав размер всех объектов, можно приблизительно вычислить необходимый размер кучи</p>
</li>
<li id="__asciidoctor-preview-273__">
<p>Поскольку на кучи объекты могут как создаваться так и удаляться из неё, то куча может получаться
неаргументированной, т.е. между объектами может быть пустая, незаполненная память. Поэтому если вы
постоянно создаете и удаляете объекты, нужно учитывать этот факт и брать размер кучи с запасом.</p>
</li>
<li id="__asciidoctor-preview-274__">
<p>Размер кучи зависит от алгоритма работы вашей программы, если вы будете создавать и удалять
последовательно объекты 100 раз, то нет никакого резона создавать кучу на 100 объектов, вполне
разумно, создать кучу под 1-2 объекта с запасом на дефрагментацию – скажем 20% и все.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-275__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-276__" class="paragraph">
<p>Как вы поняли использование кучу несет ряд трудностей с расчетом её размера, помимо этого
использование кучи может тормозить выполнение программы., см, например, <a href="#Обзор одной российской RTOS">[Обзор одной российской RTOS]</a>.
Поэтому во встроенном ПО использование кучи не приветствуется, по возможности её надо избегать,
однако некоторые архитектурные приемы невозможны без использования динамических объектов (например
для позднего связывания, или факта того, что мы не хотим использовать глобальные объекты), поэтому
использовать в курсовых вы можете, но с одним условием, в нашем программном обеспечении созданные
динамические объекты никогда не должны удаляться. Таким образом мы избежим дефрагментации кучи, а
также слежением за памятью.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-277__" class="paragraph">
<p>Для задачи размера кучи, нужно сделать те же действия что для задания размера стека, см.
<a href="#_установка_размера_стека">Установка размера стека</a></p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_задания">12. Задания</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-278__" class="paragraph">
<p>3 Задания, кто не успеет в лабораторной, завершить дома.</p>
</div>
<div class="sect2">
<h3 id="_задание_1_лекция_1_задание_1">12.1. Задание 1 #Лекция 1 Задание 1</h3>
<div id="__asciidoctor-preview-279__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-280__">
<p>Создать проект C++ c main.cpp</p>
</li>
<li id="__asciidoctor-preview-281__">
<p>Подключить к проекту файл cstartup.cpp</p>
</li>
<li id="__asciidoctor-preview-282__">
<p>Создать папки AbstractHardware/Registers/FiledValues, Common, Application, FreeRtos</p>
</li>
<li id="__asciidoctor-preview-283__">
<p>Создать структуру проекта в соотвествии со структурой папок</p>
</li>
<li id="__asciidoctor-preview-284__">
<p>Настроить STACK, HEAP</p>
</li>
<li id="__asciidoctor-preview-285__">
<p>Скопировать содержимое папки Registers и Common с проекта преподавателя в свою папку</p>
</li>
<li id="__asciidoctor-preview-286__">
<p>Написать программу в main.cpp</p>
</li>
</ol>
</div>
<div id="__asciidoctor-preview-287__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="text" class="language-text hljs">#include "gpiocregisters.hpp" //for GPIOC
#include "rccregisters.hpp"   //for RCC

int main()
{
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  GPIOC::MODER::MODER5::Output::Set() ;
  GPIOC::ODR::ODR5::Enable::Set() ;
  GPIOC::ODR::ODR5::Disable::Set() ;
  return 0 ;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-288__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-289__">
<p>Посмотреть видео: <a href="https://youtu.be/uC0jJGfDxtM" class="bare">https://youtu.be/uC0jJGfDxtM</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_задание_2">12.2. Задание 2</h3>
<div id="__asciidoctor-preview-290__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-291__">
<p>Откомпилировать и отлинковать программу</p>
</li>
<li id="__asciidoctor-preview-292__">
<p>Загрузить программу в симуляторе</p>
</li>
<li id="__asciidoctor-preview-293__">
<p>Сделать пошаговую отладку</p>
</li>
<li id="__asciidoctor-preview-294__">
<p>Настроить Debugger на отладку через StLink</p>
</li>
<li id="__asciidoctor-preview-295__">
<p>Подключить плату к компьютеру</p>
</li>
<li id="__asciidoctor-preview-296__">
<p>Загрузить программу в плату</p>
</li>
<li id="__asciidoctor-preview-297__">
<p>Выполнить пошаговую отладку</p>
</li>
<li id="__asciidoctor-preview-298__">
<p>Описать полученный результат</p>
</li>
<li id="__asciidoctor-preview-299__">
<p>Посмотреть видео: <a href="https://youtu.be/c7CasTJKw7o" class="bare">https://youtu.be/c7CasTJKw7o</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_задание_3">12.3. Задание 3</h3>
<div id="__asciidoctor-preview-300__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-301__">
<p>Запустить анализатор стека. Узнать рекомендуемый размер стека.</p>
</li>
<li id="__asciidoctor-preview-302__">
<p>Изменить в проекте размер стека на рекомендуемый</p>
</li>
<li id="__asciidoctor-preview-303__">
<p>Создать map файл</p>
</li>
<li id="__asciidoctor-preview-304__">
<p>Описать что написано в map файле</p>
</li>
<li id="__asciidoctor-preview-305__">
<p>Поставить размер кучи HEAP в 0. Объяснить почему так можно сделать. И почему STACK нельзя</p>
</li>
<li id="__asciidoctor-preview-306__">
<p>Добавить проект в Git и сделать синхронизацию с GitHub</p>
</li>
<li id="__asciidoctor-preview-307__">
<p>Сделать отчет по каждому пункту каждого задания в файле .adoc. Выложить файл в GitHub</p>
</li>
<li id="__asciidoctor-preview-308__">
<p>Прислать ссылку на GitHub преподавателю для проверки</p>
</li>
<li id="__asciidoctor-preview-309__">
<p>Посмотреть видео: <a href="https://youtu.be/TajLTcjBgIg" class="bare">https://youtu.be/TajLTcjBgIg</a></p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_лекция_2">13. Лекция 2</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_портируемость_проекта">14. Портируемость проекта</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-310__" class="paragraph">
<p>Для того, чтобы ваш проект мог хорошо портироваться на другие типы микроконтроллеров мы должны
принять некоторые меры.</p>
</div>
<div id="__asciidoctor-preview-311__" class="ulist">
<ul>
<li id="__asciidoctor-preview-312__">
<p>Применять одни и те же типы данных, имеющие один и тот же размер</p>
</li>
<li id="__asciidoctor-preview-313__">
<p>Разделять часть, которая отвечает за аппаратуру и аппаратные модули, зависящую от микроконтроллера
и бизнес логику, которая не зависит от аппаратуры</p>
</li>
<li id="__asciidoctor-preview-314__">
<p>Использовать разделение реализации и интерфейсов</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-315__" class="paragraph">
<p>Сейчас нам важны типы данных.</p>
</div>
<div class="sect2">
<h3 id="_типы_данных">14.1. Типы данных</h3>
<div id="__asciidoctor-preview-316__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-317__" class="paragraph">
<p>Одно из главных правил портируемости состоит в том, что для разных ядер микроконтроллеров один и тот
же тип переменной имел одинаковый размер. Для этого давайте разберемся, что такое тип и почему он
может иметь разную длину?
Для нашего микроконтроллера компилятор поддерживает следующие типы, см <a href="#Встроенные типа С++">[Встроенные типа С++]</a>.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-318__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure3.png" alt="800" width="1280">
</div>
<div class="title">Рисунок 24. Типы данных в С++</div>
</div>
</div>
<div class="sect2">
<h3 id="_встроенные_типы">14.2. Встроенные типы</h3>
<table id="__asciidoctor-preview-319__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 2. Встроенные типы С++</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Тип</th>
<th class="tableblock halign-left valign-top">Длина</th>
<th class="tableblock halign-left valign-top">Комментарий</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>bool</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Представляет значения, которые могут быть или <strong>true</strong>, или <strong>false</strong>.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>char</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Используется для символов ASCII в старых строках в стиле C или в объектах std::string,
которые никогда не будут преобразовываться в Юникод.</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>unsigned char</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Аналог байта. В С++17 стандарте появился тип std::byte</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Целочисленное значение. Выбор по умолчанию для целых чисел</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>unsigned int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Беззнаковое целое число</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>float</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Число с плавающей точкой, поддерживается аппаратно некоторыми микроконтроллерами</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>double</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Число с плавающей запятой двойной точности. Выбор по умолчанию для значений с плавающей
точкой</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_модификаторы_типов_данных">14.3. Модификаторы типов данных</h3>
<table id="__asciidoctor-preview-344__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 3. Встроенные типа С++ модификаторы</caption>
<colgroup>
<col style="width: 20%;">
<col style="width: 10%;">
<col style="width: 70%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Тип</th>
<th class="tableblock halign-left valign-top">Длина</th>
<th class="tableblock halign-left valign-top">Комментарий</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>short int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Целочисленное знаковое значение укороченной длины</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>unsigned short int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Целочисленное беззнаковое значение укороченной длины</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>long int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Выбор по умолчанию для целочисленных значений. На платформах на которых int равен по
длине unsigned short int может быть длиннее int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>unsigned long int</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Целое число двойной длины. На платформах на которых int равен по длине unsigned short int может быть
длиннее int</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>long double</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Число с плавающей точкой двойной точности	с двойной точностью</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_размеры_типов_данных">14.4. Размеры типов данных</h3>
<div id="__asciidoctor-preview-363__" class="paragraph">
<p>Размеры типов не четко определены и могут отличаться для различных микроконтроллеров. Для размеров
типов существует правило:</p>
</div>
<div id="__asciidoctor-preview-364__" class="listingblock source">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">1             &lt;= sizeof(char)     &lt;= sizeof() &lt;= sizeof(short) &lt;= sizeof(int) &lt;= sizeof(long)
1             &lt;= sizeof(bool)     &lt;= sizeof(long)
sizeof(char)  &lt;= sizeof(long)
sizeof(float) &lt;= sizeof(double)   &lt;= sizeof(long double)
sizeof(T)     == sizeof(signed T) == sizeof(unsigned T)</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-365__" class="paragraph">
<p>Поэтому вместо прямых типов типа int, используйте псевдонимы, например:</p>
</div>
<div id="__asciidoctor-preview-366__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
std::uint32_t
</td>
<td class="hdlist2">
<p>целое беззнаковое длиной 32 бита</p>
</td>
</tr>
<tr>
<td class="hdlist1">
std::int64_t
</td>
<td class="hdlist2">
<p>целое знаковое длинной 64 бита</p>
</td>
</tr>
<tr>
<td class="hdlist1">
std::uint8_t
</td>
<td class="hdlist2">
<p>целое знаковое длинной 8 бит</p>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_пользовательские_типы">14.5. Пользовательские типы</h3>
<div id="__asciidoctor-preview-373__" class="paragraph">
<p>Вы можете определить свой тип сами, либо сделать псевдоним типа. Любой класс или структура,
определенная вами, будет являться вашим типом. Например:</p>
</div>
<div id="__asciidoctor-preview-374__" class="listingblock source">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">template&lt;typename T&gt;
struct Complex
{
  Complex(T r, T im): real{r}, imaginary{im} {} ;
  operator T { return sqrt(real*real + imaginary* imaginary) ;}
  Complex operator +(Complex value)
  {
    return Complex(real+ value.real, imaginary + value.imaginary) ;
  }
  private:
  T real; //вещественная часть
  T imaginary //мнимая часть
} ;

int main()
{
  Complex&lt;float&gt; value1(3.0f, 4.0f) ;
  Complex&lt;float&gt; value1(1.0f, 2.0f) ;
  value1 += value2 ;
  return 0;
}</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_псевдонимы_типов">14.6. Псевдонимы типов</h3>
<div id="__asciidoctor-preview-375__" class="paragraph">
<p>Для того, чтобы было было понятнее работать с типом можно вводить их псевдонимы (alias). С помощью
ключевого слова <strong>using</strong> ;</p>
</div>
<div id="__asciidoctor-preview-376__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">auto t = std::make_tuple(10, "Test", 3.14, 2U);  <i class="conum" data-value="1"></i><b>(1)</b>
using tMytype = decltype(t) ;  <i class="conum" data-value="2"></i><b>(2)</b>
using tShortType = std::tuple&lt;int, string, double, tU32&gt; ; <i class="conum" data-value="3"></i><b>(3)</b>

void(tMyType &amp; value) {    <i class="conum" data-value="4"></i><b>(4)</b>
  ...
}


int main() {
  using tU32 = unsigned int ;  <i class="conum" data-value="5"></i><b>(5)</b>
  tU32 i = 10U ;               <i class="conum" data-value="6"></i><b>(6)</b>

  myfunction(t) ;              <i class="conum" data-value="7"></i><b>(7)</b>
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-377__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-378__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Определяем кортеж из 4 элементов разного типа</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Объявляем псевдоним типа, который имеет кортеж (тип выводится компилятором)</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Тоже самое что и &lt;2&gt; за исключением того, что указываем тип напрямую</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Объявляем функцию, принимающую аргумент типа, который имеет кортеж</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Объявляем псевдоним типа unsigned int</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Определяем переменную типа unsigned int</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_неявное_преобразование_типов">14.7. Неявное преобразование типов</h3>
<div id="__asciidoctor-preview-385__" class="paragraph">
<p>Базовые/простые типы неявно можно привести друг к другу. Т.е</p>
</div>
<div id="__asciidoctor-preview-386__" class="listingblock source">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int a = 0; <i class="conum" data-value="1"></i><b>(1)</b>

char a = 512; <i class="conum" data-value="2"></i><b>(2)</b>

int a = 3.14;  <i class="conum" data-value="3"></i><b>(3)</b>

bool a = -4;  <i class="conum" data-value="4"></i><b>(4)</b>

bool a  = 0;  <i class="conum" data-value="5"></i><b>(5)</b></code></pre>
</div>
</div>
<div id="__asciidoctor-preview-387__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Присваимаем знаковое целое(int) число переменной целого типа</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Присваиваем знаковое целое(int) число переменной типа char. Результат в а 0 ;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Присваиваем число с плавающей точкой(double) к переменной типа int. Результат в а 3</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Присваиваем знаковое целое(int) к переменной типа bool. Результат в а true</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Присваиваем знаковое целое(int) к переменной типа bool. Результат в а false</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_явное_преобразование_типов">14.8. Явное преобразование типов</h3>
<div id="__asciidoctor-preview-393__" class="paragraph">
<p>Так как компилятор может сделать за вас, то, что вы вообще не ожидаете, не нужно использовать неявное
преобразование типа.</p>
</div>
<div id="__asciidoctor-preview-394__" class="paragraph">
<p>Вместо этого, лучше указать компилятору явное преобразование из одного типа в другой.
В этом случае, вы говорите компилятору, что я понимаю, что я делаю, это именно так и задумано</p>
</div>
<div id="__asciidoctor-preview-395__" class="paragraph">
<p>Для преобразований из одного типа используют 4 вариантов преобразования:</p>
</div>
<div id="__asciidoctor-preview-396__" class="ulist">
<ul>
<li id="__asciidoctor-preview-397__">
<p>static_cast</p>
</li>
<li id="__asciidoctor-preview-398__">
<p>const_cast</p>
</li>
<li id="__asciidoctor-preview-399__">
<p>reinterpret_cast</p>
</li>
<li id="__asciidoctor-preview-400__">
<p>dynamic_cast</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_static_cast">14.9. static_cast</h3>
<div id="__asciidoctor-preview-401__" class="paragraph">
<p><strong>static_cast</strong> позволяет сделать приведение близких типов (целые, пользовательских типов которые могут
создаваться из типов который приводится, и указатель на void* к указателю на любой тип).</p>
</div>
<div id="__asciidoctor-preview-402__" class="paragraph">
<p>Проверка производится на уровне компиляции, так что в случае ошибки сообщение будет получено в момент
сборки приложения или библиотеки.</p>
</div>
<div id="__asciidoctor-preview-403__" class="listingblock source">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int a = static_cast&lt;int&gt;(0); <i class="conum" data-value="1"></i><b>(1)</b>

int a = static_cast&lt;int&gt;(3.14);  <i class="conum" data-value="2"></i><b>(2)</b>

bool a = static_cast&lt;bool&gt;(-4);  <i class="conum" data-value="3"></i><b>(3)</b>

bool a  = static_cast&lt;bool&gt;(0);  <i class="conum" data-value="4"></i><b>(4)</b>

float f = 3.14f ;     <i class="conum" data-value="5"></i><b>(5)</b>

float f = static_cast&lt;float&gt;(3.14) ;  <i class="conum" data-value="6"></i><b>(6)</b>

Complex f = static_cast&lt;3.14&gt; <i class="conum" data-value="7"></i><b>(7)</b></code></pre>
</div>
</div>
<div id="__asciidoctor-preview-404__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-405__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Явно говорим, что 0 должен восприниматься как тип (int), хотя он и так является литералом типа int.
Но все ли помнят об этом?</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Явно говорим, что 3.14 воспринимать как int, т.е взять только целую часть.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Явно говорим, -4 нужно воспринять как bool тип, в данном случае true.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Явно говорим, 0 нужно воспринять как bool тип, в данном случае false.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Явно говорим, что 3.14 это float</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Явно говорим, что 3.14 это float</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Комплексное число может создаться из double, поэтому тут будет работать static_cast.</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_reinterpret_cast">14.10. reinterpret_cast</h3>
<div id="__asciidoctor-preview-413__" class="paragraph">
<p><strong>reinterpret_cast</strong> преобразует типы, несовместимыми друг с другом, и используется для:</p>
</div>
<div id="__asciidoctor-preview-414__" class="ulist">
<ul>
<li id="__asciidoctor-preview-415__">
<p>В свой собственный тип</p>
</li>
<li id="__asciidoctor-preview-416__">
<p>Указателя в интегральный тип</p>
</li>
<li id="__asciidoctor-preview-417__">
<p>Интегрального типа в указатель</p>
</li>
<li id="__asciidoctor-preview-418__">
<p>Указателя одного типа в указатель другого типа</p>
</li>
<li id="__asciidoctor-preview-419__">
<p>Указателя на функцию одного типа в указатель на функцию другого типа</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-420__" class="listingblock source">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">auto ptr = reinterpret_cast&lt;volatile uint32_t *&gt;(0x40010000) ; <i class="conum" data-value="1"></i><b>(1)</b>
auto value = *ptr ; <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div id="__asciidoctor-preview-421__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Преобразует адрес 0x40010000 в указатель типа volatile uint32_t</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Записывает в переменную value (типа) значение лежащее по указателю ptr, указывающего на адрес
0x40010000</td>
</tr>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_память">15. Память</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-424__" class="paragraph">
<p>Как говорилось в первой лекции, ARM имеет общее адресное пространство для данных и команд.</p>
</div>
<div id="__asciidoctor-preview-425__" class="paragraph">
<p>Ядро ARM имеет 4 Гбайт последовательной памяти с адресов 0x00000000 до 0xFFFFFFFF.</p>
</div>
<div id="__asciidoctor-preview-426__" class="paragraph">
<p>Различные типы памяти могут быть расположены по эти адресам. Обычно микроконтроллер имеет постоянную
память, из которой можно только читать (ПЗУ) и оперативную память, из которой можно читать и в
которую можно писать (ОЗУ).</p>
</div>
<div id="__asciidoctor-preview-427__" class="paragraph">
<p>Также часть адресов этой памяти отведены под регистры управления и регистры периферии.</p>
</div>
<div class="sect2">
<h3 id="_память_микроконтроллера_cortexm4">15.1. Память микроконтроллера CortexM4</h3>
<div id="__asciidoctor-preview-428__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure4.png" alt="300" width="500">
</div>
<div class="title">Рисунок 25. Карта памяти микропроцессора</div>
</div>
<div id="__asciidoctor-preview-429__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-430__" class="paragraph">
<p>Микроконтроллер  на ядре Cortex M4 выполнен по Гарвардской архитектуре, память здесь разделена на
три типа:</p>
</div>
<div id="__asciidoctor-preview-431__" class="ulist">
<ul>
<li id="__asciidoctor-preview-432__">
<p>ПЗУ  (FLASH память в которой храниться программа)</p>
</li>
<li id="__asciidoctor-preview-433__">
<p>ОЗУ память для хранения временных данных (туда же можно по необходимости переместить программу и
выполнить её из ОЗУ), память в которой находятся регистры отвечающие за настройку и работу с
периферией и</p>
</li>
<li id="__asciidoctor-preview-434__">
<p>Память для хранения постоянных данных ЕЕPROM.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-435__" class="exampleblock">
<div class="content">
<div id="__asciidoctor-preview-436__" class="paragraph">
<p>Адресное пространство памяти программы (ПЗУ) находится по адресам <strong>0x00000000</strong> по <strong>0x1FFFFFFF</strong></p>
</div>
<div id="__asciidoctor-preview-437__" class="paragraph">
<p>Адресное пространство ОЗУ находится по адресам  <strong>0x20000000</strong> по <strong>0x3FFFFFFF</strong></p>
</div>
<div id="__asciidoctor-preview-438__" class="paragraph">
<p>Адресное пространство для регистров периферии находится по адресам с <strong>0x40000000</strong>  по <strong>0x5FFFFFFF</strong></p>
</div>
<div id="__asciidoctor-preview-439__" class="paragraph">
<p>Памяти EEPROM микропроцессора Stm32F411RE не содержит, см <a href="#Карта памяти микропроцессора">[Карта памяти микропроцессора]</a>.
Более подробно вы можете изучить адресное пространство микропроцессора в спецификации на микропроцессор <a href="#12">[12]</a>.</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_память_для_расположения_данных">15.2. Память для расположения данных</h3>
<div id="__asciidoctor-preview-440__" class="paragraph">
<p>Данные в памяти могут быть расположены 3 различными способами:</p>
</div>
<div id="__asciidoctor-preview-441__" class="ulist">
<ul>
<li id="__asciidoctor-preview-442__">
<p>Авто(локальные) переменные, которые являются локальными в функции располагаются в регистрах или в стеке.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-443__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-444__" class="paragraph">
<p>Такие переменные "существуют" только внутри функции, как только функция закончится и вернется к вызывающему
объекту, эти переменные становятся не валидными.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-445__" class="ulist">
<ul>
<li id="__asciidoctor-preview-446__">
<p>Глобальные переменные или статические переменные. В этом случае они инициализируются единожды.</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-447__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-448__" class="paragraph">
<p>Static означает, что та память, которая была выделена под эту переменную не будет изменяться и
закрепляется за этой переменной до конца работы приложения.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-449__" class="ulist">
<ul>
<li id="__asciidoctor-preview-450__">
<p>Динамически размещаемые данные. Данные создаваемые на Куче(Heap)</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-451__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-452__" class="paragraph">
<p>Если заранее не известно, сколько объектов нужно создать, и сколько памяти они будут отнимать, то придется
создавать их динамически, например с помощью оператора new, в таком случае, объекты будут создаваться в куче.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_память_под_функциикоманды">15.2.1. Память под функции(команды)</h4>
<div id="__asciidoctor-preview-453__" class="paragraph">
<p>Для расположения функций используется та же самая память с границами от <strong>0x00000000 - 0xFFFFFFFF</strong>.</p>
</div>
<div id="__asciidoctor-preview-454__" class="paragraph">
<p>По умолчанию весь код будет лежать в сегменте .text, который расположен в readonly памяти (обычно в ROM),
но можно разместить функции и в ОЗУ.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_указатели">15.3. Указатели</h3>
<div id="__asciidoctor-preview-455__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-456__" class="paragraph">
<p>Как мы уже поняли, данные могут находится в ОЗУ или ПЗУ. Каждой переменной содержащей данные соответствует
некий адрес памяти. К переменной можно обратиться непосредственно обращаясь к самой переменной, тогда мы
можем напрямую писать или читать значение с адреса переменной, либо можно обратиться косвенно, через указатель
или ссылку.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-457__" class="paragraph">
<p>Указатель это переменная, которая хранит адрес какой-то другой переменной:</p>
</div>
<div id="__asciidoctor-preview-458__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main() {
  int  c = 463 ;   <i class="conum" data-value="1"></i><b>(1)</b>
  int* ptr = &amp;c ;  <i class="conum" data-value="2"></i><b>(2)</b>
  return 0;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-459__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-460__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Объявляем переменную <strong>c</strong> типа <strong>int</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>объявляем указатель <strong>ptr</strong> на переменную <strong>c</strong> типа <strong>int</strong></td>
</tr>
</table>
</div>
</div>
</div>
<div id="Указатель" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure5.png" alt="400" width="400">
</div>
<div class="title">Рисунок 26. Указатель</div>
</div>
<div id="__asciidoctor-preview-463__" class="paragraph">
<p>Размер указателя для нашего микроконтроллера 4 байта (32 бита).</p>
</div>
</div>
<div class="sect2">
<h3 id="_взятие_адреса_и_разыменование_указателя">15.4. Взятие адреса и разыменование указателя.</h3>
<div id="__asciidoctor-preview-464__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main() {
  int  c = 463 ;              <i class="conum" data-value="1"></i><b>(1)</b>
  int* ptr = &amp;c ;             <i class="conum" data-value="2"></i><b>(2)</b>
  cout &lt;&lt; &amp;c ;                <i class="conum" data-value="3"></i><b>(3)</b>
  cout &lt;&lt; c ;                 <i class="conum" data-value="4"></i><b>(4)</b>

  *ptr = 5;                   <i class="conum" data-value="5"></i><b>(5)</b>
  cout &lt;&lt; c &lt;&lt; ": " &lt;&lt; *ptr;  <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-465__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Объявление переменной</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Оператор &amp; - оператор взятия адреса.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Выведется адрес переменной <strong>с</strong> (0х100)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Выведется значение переменной с (463)</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Операция разыменование указателя, записываем в переменную по адресу, который лежит в ptr, число 5</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Вывод значения переменной с и значения лежащего по адресу, на который указывает указатель (5: 5)
По сути с и *ptr это одно и то же.</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_операции_над_указателями">15.5. Операции над указателями</h3>
<div id="__asciidoctor-preview-472__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-473__" class="paragraph">
<p>Указатели можно складывать, вычитать, сравнивать. Но указатели должны быть одного типа. Т.е. не нужно
например складывать укатель типа <strong>char</strong> * и <strong>int</strong> *</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-474__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main() {
  int  arr[] = {1,2,3,4,5} ;    <i class="conum" data-value="1"></i><b>(1)</b>
  int* ptr = arr ;              <i class="conum" data-value="2"></i><b>(2)</b>

  ptr ++ ;                      <i class="conum" data-value="3"></i><b>(3)</b>
  int a = *(ptr + 4) ;          <i class="conum" data-value="4"></i><b>(4)</b>
  if(ptr != nullptr)            <i class="conum" data-value="5"></i><b>(5)</b>
    cout &lt;&lt; a &lt;&lt; ": " &lt;&lt; *ptr;  <i class="conum" data-value="6"></i><b>(6)</b>
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-475__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Объявление массива <strong>arr</strong> из 5 элементов. В целом можно считать, что массив <strong>arr</strong> это указатель на первый элемент массива.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Обявления указателя на массив типа <strong>int</strong> ;</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Увеличиваем указатель на 1. На самом деле мы смещаемся по адресам на размер равный <strong>size_of(int)</strong>, т.е. на 4 байта. Т.е
в данном случае указатель <strong>ptr</strong> стал указывать на элемент массива <strong>arr[1]</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Объявляем переменную <strong>а</strong> типа <strong>int</strong> и присваиваем ей значение <strong>аrr[4]</strong>.</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Сравнение указателя с nullptr указателем.</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>Вывод значения <strong>а</strong> и значения по адресу в указателе <strong>ptr</strong>. Вывод (5: 2)</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_сложение_указателей">15.6. Сложение указателей</h3>
<div id="__asciidoctor-preview-482__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main() {
  int  arr[] = {1,2,3,4,5} ;    <i class="conum" data-value="1"></i><b>(1)</b>
  int* ptr = arr ;              <i class="conum" data-value="2"></i><b>(2)</b>

  ptr ++ ;                      <i class="conum" data-value="3"></i><b>(3)</b>
  int a = *(ptr + 4) ;          <i class="conum" data-value="4"></i><b>(4)</b>
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-483__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure6.png" alt="800" width="800">
</div>
<div class="title">Рисунок 27. Сложение указателей</div>
</div>
</div>
<div class="sect2">
<h3 id="_константный_указатель_и_указатель_на_константу">15.7. Константный указатель и указатель на константу</h3>
<div id="__asciidoctor-preview-484__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main() {
  const auto pi[] = {3.14, 3.14159} ;
  const double *ptr = pi ;
  *ptr = 3.14159 ;                  <i class="conum" data-value="1"></i><b>(1)</b>
  ptr++ ;                           <i class="conum" data-value="2"></i><b>(2)</b>
  count &lt;&lt; *ptr ;                   <i class="conum" data-value="3"></i><b>(3)</b>
  const double * const ptr1 = pi ;  <i class="conum" data-value="4"></i><b>(4)</b>
  ptr1++  ;                         <i class="conum" data-value="5"></i><b>(5)</b>
  retrun 0 ;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-485__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Пытаемся поменять значение по указателю <strong>ptr</strong> (pi[0]). Ошибка, указатель на константу, нельзя
поменять значение константы</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Увеличиваем указатель на 1 (теперь указатель указывает на p[1]).</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Вывод значения по указателю (3.14159)</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Объявляем константный указатель на константу</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Нельзя изменить указатель, он константный</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_ссылка">15.8. Ссылка</h3>
<div id="__asciidoctor-preview-491__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main(){
  int a = 0;
  int &amp;ref = a ;                <i class="conum" data-value="1"></i><b>(1)</b>
  ref = 10;                     <i class="conum" data-value="2"></i><b>(2)</b>
  cout &lt;&lt; &amp;ref &lt;&lt; ": " &lt;&lt; ref ; <i class="conum" data-value="3"></i><b>(3)</b>
  return 0 ;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-492__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Объявляем ссылку на переменную <strong>а</strong></td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Записываем в переменную <strong>а</strong> число 10</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Выводим адрес перменной <strong>а</strong> и значение переменной <strong>a</strong></td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-496__" class="openblock">
<div class="content">
<div id="__asciidoctor-preview-497__" class="paragraph">
<p>Ссылка это псевдоним переменной.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-498__" class="ulist">
<ul>
<li id="__asciidoctor-preview-499__">
<p>У ссылки нельзя взять адрес. Если применить оператор взятия адреса к ней, то будет выведен адрес
переменной, на которую она ссылается</p>
</li>
<li id="__asciidoctor-preview-500__">
<p>Ссылка ведет себя почти также как константный указатель. Её нельзя изменять, складывать, вычитать</p>
</li>
<li id="__asciidoctor-preview-501__">
<p>Ссылки нельзя сравнивать</p>
</li>
<li id="__asciidoctor-preview-502__">
<p>Ссылка не может быть не проинициализирована.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_регистр">16. Регистр</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-503__" class="ulist">
<ul>
<li id="__asciidoctor-preview-504__">
<p>Существуют регистры общего назначения и специальные регистры. Регистры общего назначения расположены
внутри ядра микроконтроллера(сверхбыстрая память).</p>
</li>
<li id="__asciidoctor-preview-505__">
<p>Регистры общего назначения - это сверхбыстрая память внутри процессора, предназначенная для
хранения адресов и промежуточных результатов вычислений (регистр общего назначения/регистр данных)
или данных, необходимых для работы самого процессора.</p>
</li>
<li id="__asciidoctor-preview-506__">
<p>Регистры специального назначения расположены в ОЗУ микроконтроллера и используются для управления
процессором и периферийными устройствами.</p>
</li>
<li id="__asciidoctor-preview-507__">
<p>Каждый регистр в архитектуре ARM представляет собой ресурс памяти и имеет длину в 32 бита, где каждый
бит можно представить в виде выключателя с помощью которого осуществляется управление тем или иным
параметром микроконтроллера <a href="#10">[10]</a>.</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_регистры_общего_назначения">16.1. Регистры общего назначения</h3>
<div id="__asciidoctor-preview-508__" class="paragraph">
<p>С точки зрения прикладного программиста, процессор располагает 16-ю 32-разрядными регистрами общего
назначения (РОН, GPR), из которых три на деле имеют специальные функции:</p>
</div>
<div id="__asciidoctor-preview-509__" class="ulist">
<ul>
<li id="__asciidoctor-preview-510__">
<p>Оперативные регистры</p>
</li>
<li id="__asciidoctor-preview-511__">
<p>Вспомогательные регистры</p>
</li>
<li id="__asciidoctor-preview-512__">
<p>Специальные регистры</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_оперативные_регистры">16.2. Оперативные регистры</h3>
<div id="__asciidoctor-preview-513__" class="paragraph">
<p>Регистры <strong>R0-R3</strong>, <strong>R12</strong> являются оперативными(sratch) регистрами. Любая функция может использовать эти
регистры по своему усмотрению и уничтожать содержимое этих регистров.</p>
</div>
<div id="__asciidoctor-preview-514__" class="paragraph">
<p>Если функции нужны значения этих регистров после вызова другой функции, она должна сохранить их на
стеке, а после вызова восстановить.</p>
</div>
</div>
<div class="sect2">
<h3 id="_вспомогательные_регистры">16.3. Вспомогательные регистры</h3>
<div id="__asciidoctor-preview-515__" class="paragraph">
<p>Регистры от <strong>R4-R11</strong> являются вспомогательными. Любая функция должна сохранить их на входе, а при
выходе восстановить их значение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_специальные_регистры">16.4. Специальные регистры</h3>
<div id="__asciidoctor-preview-516__" class="ulist">
<ul>
<li id="__asciidoctor-preview-517__">
<p>Регистр указателя на стек <strong>R13/SP</strong>, должен всегда указывать на последний элемент стека или ниже него.</p>
</li>
<li id="__asciidoctor-preview-518__">
<p>Регистр <strong>R15/PC</strong> есть программный счетчик.</p>
</li>
<li id="__asciidoctor-preview-519__">
<p>Регистр <strong>R14/LR</strong>, содержит адрес возврата функции.</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_регистр_специального_назачения">16.5. Регистр специального назачения</h3>
<div id="Register" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure1.png" alt="800" width="800">
</div>
<div class="title">Рисунок 28. Схематичное изображение регистра</div>
</div>
<div id="__asciidoctor-preview-520__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-521__" class="ulist">
<ul>
<li id="__asciidoctor-preview-522__">
<p>Название регистра</p>
</li>
</ul>
</div>
</div>
</div>
<div id="__asciidoctor-preview-523__" class="ulist">
<ul>
<li id="__asciidoctor-preview-524__">
<p>Адрес регистра обозначается 32-битным шестнадцатеричным числом.</p>
</li>
<li id="__asciidoctor-preview-525__">
<p>Тип доступа к ячейкам регистра.</p>
</li>
<li id="__asciidoctor-preview-526__">
<p>Длина - количество ячеек в одном регистре. Мы будем работать с 32-битными регистрами.</p>
</li>
<li id="__asciidoctor-preview-527__">
<p>Поле - набор ячеек регистра, отвечающих за работу одной из функции микроконтроллера</p>
</li>
<li id="__asciidoctor-preview-528__">
<p>Значение поля - есть пространство всех возможных величин, которые может принимать поле</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-529__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-530__" class="paragraph">
<p>Значение поля зависит от длины поля. Т.е. если поле имеет длину 2, то существует 4 возможные
значения поля (0,1,2,3). Так же как у регистра, у полей и значений полей есть режим доступа (чтение,
записать, чтение и запись)</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_пример_регистра_специального_назначения">16.6. Пример регистра специального назначения</h3>
<div id="__asciidoctor-preview-531__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-532__" class="paragraph">
<p>Как было сказано выше регистры используются для управления микроконтроллером и его периферией.
Например, чтобы запустить таймер 1 на счет, необходимо в Таймере1, в регистре CR1(Control Register1)
в поле CEN (Counter Enable) установить значение 1 (Enable).</p>
</div>
</div>
</div>
<div id="RegisterCR1" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure2.png" alt="800" width="800">
</div>
<div class="title">Рисунок 29. Регистр CR1 Таймера 1</div>
</div>
<div id="__asciidoctor-preview-533__" class="literalblock">
<div class="content">
<pre>Бит 0 CEN: Включить счетчик
    0: Счетчик включен: Disable
    1: Счетчик выключен: Enable</pre>
</div>
</div>
<div id="__asciidoctor-preview-534__" class="paragraph">
<p>Здесь, например, CEN — это поле размером 1 бит имеющее смещение 0 относительно начала регистра.
А Enable(1) и Disable(0) это его возможные значения.</p>
</div>
</div>
<div class="sect2">
<h3 id="_доступ_к_регистру_специального_назначения">16.7. Доступ к регистру специального назначения</h3>
<div id="__asciidoctor-preview-535__" class="paragraph">
<p>Так как регистр специального назначения - это просто адресуемая ячейка памяти, то в коде это может
мы можем обратиться к данным по этому адресу, разыменовывая указатель, указывающий на этот адрес:</p>
</div>
<div id="__asciidoctor-preview-536__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main()
{
  *reinterpret_cast&lt;uint32_t *&gt;(0x40010000) |= 1 &lt;&lt; 0 ; <i class="conum" data-value="1"></i><b>(1)</b>
  TIM1::CR1::CEN::Enable::Set() ;                       <i class="conum" data-value="2"></i><b>(2)</b>
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-537__" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Записываем 1 в нулевой бит ячейки памяти (регистра) по адресу 0x40010000</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Тоже самое, но с использование специального класса на С++</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_работа_с_регистрами_периферии_через_обертку_на_с">16.8. Работа с регистрами периферии через обертку на С++</h3>
<div id="__asciidoctor-preview-540__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-541__" class="paragraph">
<p>Для того, чтобы настроить определенное периферийное устройство процессора, необходимо изменить
значение поля соответствующем регистре.</p>
</div>
<div id="__asciidoctor-preview-542__" class="paragraph">
<p>Для более удобной работы с регистрами можно использовать С++ обертку. Эта обертка позволяет обращаться
к регистрам в форме очень похоже с тем, как эти регистры описаны в документации.</p>
</div>
<div id="__asciidoctor-preview-543__" class="paragraph">
<p>Так, например, для запуска внешнего источника частоты, необходимо обратиться к регистру “CR”
периферии “RCC”, полю HSEON и установить в нем значение Enable.
Операция обращения к регистру выглядит следующим образом:</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-544__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">---
int main()
{
  RCC::CR::HSEON::Enable::Set() ;
}
---</code></pre>
</div>
</div>
<div id="RCC::CR" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure9.png" alt="Figure9">
</div>
<div class="title">Рисунок 30. Подсказка для регистра CR модуля периферии RCC</div>
</div>
</div>
<div class="sect2">
<h3 id="_некоторые_моменты_при_работе_с_оберткой_с_для_регистров">16.9. Некоторые моменты при работе с оберткой С++ для регистров</h3>
<div id="__asciidoctor-preview-545__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-546__" class="paragraph">
<p>Код для регистров был сгенерирован автоматически, см <a href="#13">[13]</a>. Поэтому по умолчанию все значения полей
называются в формате ValueX, где Х-само значение. Поэтому тот момент когда нужно их использовать,
нужно заглянуть в документацию и поменять слова Value, на что-то более внятное.</p>
</div>
<div id="__asciidoctor-preview-547__" class="paragraph">
<p>Для того, чтобы найти место где объявляется значение поля, необходимо правой мышкой нажать на значении
и найти все его объявления.</p>
</div>
</div>
</div>
<div id="RCC::CR" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure10.png" alt="Figure10">
</div>
<div class="title">Рисунок 31. Поиск места объявления значения</div>
</div>
<div id="__asciidoctor-preview-548__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-549__" class="paragraph">
<p>На самом деле, все значения полей определены в файлах, которые лежат в папке:
AbstractHardware\Registers\STM32F411\FieldValues</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-550__" class="paragraph">
<p>Можно открыть файл с именем [имя периферии]filedvalues.hpp и найти там структуру названием
ИМЯ ПЕРИФЕРИ_ИМЯ РЕГИСТРА_ИМЯ ПОЛЯ_Values.</p>
</div>
<div id="__asciidoctor-preview-551__" class="paragraph">
<p>Например, для значений поля HSEON модуля периферии RCC, регистра CR, необходимо:</p>
</div>
<div id="__asciidoctor-preview-552__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-553__">
<p>открыть файл AbstractHardware\Registers\STM32F411\FieldValues\rccfieldvalues.hpp,</p>
</li>
<li id="__asciidoctor-preview-554__">
<p>найти структуру struct RCC_CR_HSEON_Values</p>
</li>
<li id="__asciidoctor-preview-555__">
<p>поменять в этой стурутуре <strong>Value0</strong> на <strong>Disable</strong>, а <strong>Value1</strong> на <strong>Enable</strong>.</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_соглашение_об_вызовах">17. Соглашение об вызовах</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-556__" class="paragraph">
<p>Соглашение об вызовах включает в себя:
* Объявление функции
* Компоновка С и С++ кода
* Последовательность использования оперативных регистров и вспомогательные регистров
* Вход в функцию
* Выход из функции
* Обработка адреса возврата</p>
</div>
<div class="sect2">
<h3 id="_объявление_функции">17.1. Объявление функции</h3>
<div id="__asciidoctor-preview-557__" class="paragraph">
<p>Функция должна быть объявлена в таком порядке, чтобы компилятор мог узнать как её вызвать.
Объявление функции может выглядеть следующим образом:</p>
</div>
<div id="__asciidoctor-preview-558__" class="exampleblock">
<div class="content">
<div id="__asciidoctor-preview-559__" class="paragraph">
<p>int MyFunction(int first, char * second);</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-560__" class="paragraph">
<p>Все что знает об этой функции компилятор, это то, что она принимает два параметра: целое и указатель
на символ. И функция должна вернуть целое значение. Этого достаточно для компилятора, чтобы понять
как вызвать эту функцию.</p>
</div>
</div>
<div class="sect2">
<h3 id="_компоновка_с_и_с_кода">17.2. Компоновка С и С++ кода</h3>
<div id="__asciidoctor-preview-561__" class="paragraph">
<p>В C+ , функция может компоноваться либо как С +, либо как С функция. Пример объявления функции
с Си компоновкой:</p>
</div>
<div id="__asciidoctor-preview-562__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="c" class="language-c hljs">extern "C" {
  int F(int);
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-563__" class="paragraph">
<p>Если вы хотите вызвать функции ассемблера из С++, то лучше объявить эту функцию, как имеющую тип
компоновки Си</p>
</div>
</div>
<div class="sect2">
<h3 id="_вход_в_функцию">17.3. Вход в функцию</h3>
<div id="__asciidoctor-preview-564__" class="paragraph">
<p>Параметры передающие в функцию могут использовать два метода:</p>
</div>
<div id="__asciidoctor-preview-565__" class="ulist">
<ul>
<li id="__asciidoctor-preview-566__">
<p>Через регистры</p>
</li>
<li id="__asciidoctor-preview-567__">
<p>Через стек</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-568__" class="paragraph">
<p>Для большей эффективности параметры передаются через регистры, но их число ограничено, поэтому
если регистров не хватает, то используется стек. Для передачи параметров используются
оперативные регистры <strong>R0:R3</strong></p>
</div>
</div>
<div class="sect2">
<h3 id="_выход_из_функции">17.4. Выход из функции</h3>
<div id="__asciidoctor-preview-569__" class="paragraph">
<p>Функция может вернуть значение. Для возврата значения используются регистры <strong>R0:R1</strong>. Если значение
больше 64 бит, то в регистр R0 записывается адрес где лежат данные.</p>
</div>
<div id="__asciidoctor-preview-570__" class="paragraph">
<p>Вызывающая функция обязана очистить стек, после того, как вызываемая функция вернула значение.</p>
</div>
</div>
<div class="sect2">
<h3 id="_операторы">17.5. Операторы</h3>
<div id="__asciidoctor-preview-571__" class="ulist">
<ul>
<li id="__asciidoctor-preview-572__">
<p>Арифметические операторы</p>
</li>
<li id="__asciidoctor-preview-573__">
<p>Операторы сравнения</p>
</li>
<li id="__asciidoctor-preview-574__">
<p>Логические операторы</p>
</li>
<li id="__asciidoctor-preview-575__">
<p>Побитовые операторы</p>
</li>
<li id="__asciidoctor-preview-576__">
<p>Составное присваивание</p>
</li>
<li id="__asciidoctor-preview-577__">
<p>Операторы работы с указателями и членами класса</p>
</li>
<li id="__asciidoctor-preview-578__">
<p>Функторы, тернарные операции, sizeof(), запятая, приведение типа, new</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-579__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-580__" class="paragraph">
<p>Все операторы можно переопределить</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_арифметические_операторы">17.6. Арифметические операторы</h3>
<div id="__asciidoctor-preview-581__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-582__" class="paragraph">
<p>Арифметические операторы предоставляют базовые арифметические действия над типами, такие как
сложение, вычитание, деление, умножение, остаток от деления, присваивание. Любой оператор
может быть определен для множества пользовательского типа. Т.е. вы можете создать свой тип и определить
арифметические операторы для вашего типа. Например, можно определить арифметические операторы для
множества комплексных чисел, которые могут быть представлены в виде вашего собственного
пользовательского типа.</p>
</div>
</div>
</div>
<table id="__asciidoctor-preview-583__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 4. Арифметические операторы</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Операция</th>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Комментарий</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Присваивание</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a = b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Сложение</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a + b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Вычитание</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a - b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Унарный плюс</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Унарный минус</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-a</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Умножение</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">*</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a * b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Деление</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">/</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a / b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Остаток от деления</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">%</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a % b</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Инкремет  (пост и предфиксный)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">++</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#43;&#43;a  и  a&#43;&#43;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Декремент (пост и предфиксный)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">- -</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">--a и a--</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_логические_операторы">17.7. Логические операторы</h3>
<div id="__asciidoctor-preview-617__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-618__" class="paragraph">
<p>Логические операторы предоставляют действия над булевым типов. Результат действия этих операторов
может быть только <strong>true</strong> или <strong>false</strong></p>
</div>
</div>
</div>
<table id="__asciidoctor-preview-619__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 5. Логические операторы</caption>
<colgroup>
<col style="width: 21.0526%;">
<col style="width: 21.0526%;">
<col style="width: 21.0526%;">
<col style="width: 36.8422%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Операция</th>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Комментарий</th>
<th class="tableblock halign-left valign-top">Пример</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Логическое отрицание, НЕ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">!true &#8658; false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Логическое умножение, И</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &amp;&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true &amp;&amp; false &#8658; false</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Логическое сложение, ИЛИ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#124;&#124;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#124; &#124;  b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">true &#124; &#124;  false &#8658; true</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_побитовые_операторы">17.8. Побитовые операторы</h3>
<div id="__asciidoctor-preview-636__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-637__" class="paragraph">
<p>Побитовые операторы предоставляют действия с битами.</p>
</div>
</div>
</div>
<table id="__asciidoctor-preview-638__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 6. Побитовые операторы</caption>
<colgroup>
<col style="width: 21.0526%;">
<col style="width: 21.0526%;">
<col style="width: 21.0526%;">
<col style="width: 36.8422%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Операция</th>
<th class="tableblock halign-left valign-top">Оператор</th>
<th class="tableblock halign-left valign-top">Комментарий</th>
<th class="tableblock halign-left valign-top">Пример</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовая инверсия</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">~</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">~a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 0; ~a &#8658; 0xFF</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое И</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&amp;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &amp; b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 1, b = 3; a &amp; b &#8658; 1</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое ИЛИ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#124;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &#124; b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 1, b = 3; a &#124; b &#8658; 3</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовое исключающее ИЛИ</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a ^ b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 1, b = 3; a ^ b &#8658; 2</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовый сдвиг влево</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&lt;&lt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &lt;&lt; b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 1, b = 3; a &lt;&lt; b &#8658; 8</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Побитовый сдвиг вправо</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&gt;&gt;</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a &gt;&gt; b</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">unsigned char a = 8, b = 3; a &gt;&gt; b &#8658; 1</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_отладочная_плата">18. Отладочная плата</h2>
<div class="sectionbody">
<table id="__asciidoctor-preview-667__" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>STM32F411RET6 ядро:</strong> ARM® 32-bit Cortex™-M4</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>CP2102:</strong> USB - UART преобразователь</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>Arduino разъем:</strong> для подключения Arduino шилдов ​</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>ICSP interface:</strong> Arduino ICSP</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>USB разъем:</strong> USB коммуникационный интерфейс</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>SWD interface:</strong> для программирования и отладки</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>ST Morpho разъемы:</strong>  для упрощения расширения​</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>​<strong>6-12 V DC вход питания</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>Пользовательская кнопка</strong></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>​ *Кнопка Сброса</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>Индикатор питания</strong></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>Пользовательские светодиоды</strong></p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>Индикаторы последовательного порта Rx/Tx</strong> ​</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><strong>8 MHz кварцевый резонатор</strong></p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p><strong>32.768 KHz кварцевый резонатор</strong></p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p><a href="http://www.waveshare.com/xnucleo-F411RE.htm" class="bare">http://www.waveshare.com/xnucleo-F411RE.htm</a></p>
</div></div></td>
</tr>
</tbody>
</table>
<div id="__asciidoctor-preview-684__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure11.png" alt="300" width="300">
</div>
<div class="title">Рисунок 32. Отладочная плата</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_микроконтроллер_st32f411re">19. Микроконтроллер ST32F411RE</h2>
<div class="sectionbody">
<div id="Микроконтроллер" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure7.png" alt="600" width="600">
</div>
<div class="title">Рисунок 33. Функциональные блоки микроконтроллера STM32F411</div>
</div>
<div class="sect2">
<h3 id="_ядро_cortexm4">19.1. Ядро CortexM4</h3>
<div id="__asciidoctor-preview-685__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure12.png" alt="500" width="500">
</div>
<div class="title">Рисунок 34. Ядро CortexM4</div>
</div>
<div id="__asciidoctor-preview-686__" class="ulist">
<ul>
<li id="__asciidoctor-preview-687__">
<p>Ядро Cortex построено по гарвардской архитектуре с разделением шины данных и кода. ​</p>
</li>
<li id="__asciidoctor-preview-688__">
<p>Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения, которые выполняются за 1 цикл (деление со знаком (SDIV) или без (UDIV) занимает от 2 до 12 тактов в зависимости от размера операндов​</p>
</li>
<li id="__asciidoctor-preview-689__">
<p>Ядро Cortex-М4 поддерживает 8/16/32-разрядные операции умножения со сложением​</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_характеристики_ядра_cortexm4">19.2. Характеристики ядра CortexM4</h3>
<table id="__asciidoctor-preview-690__" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
<col style="width: 25%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Параметр​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARM7TDMI​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARM Cortex-M3​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARM Cortex-M4​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Архитектура​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARMv4T (Фон Неймана)​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARMv7 (Гарвардская)​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ARMv7 (Гарвардская)​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Набор инструкций​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thumb/ARM​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thumb/Thumb-2​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Thumb/Thumb-2, DSP, SIMD, FP​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Конвейер​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 уровня​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 уровня + предсказание ветвлений​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 уровня + предсказание ветвлений​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Прерывания​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FIQ/IRQ​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NMI (немаскируемые) + от 1 до 240 физических источников прерываний​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NMI (немаскируемые) + от 1 до 240 физических источников прерываний​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Длительность входа в обработчик прерывания​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24-42 цикла​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 циклов​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">12 циклов​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Длительность переключения между обработчиками прерываний​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">24 цикла​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 циклов​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6 циклов​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Режимы пониженного энергопотребления​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Нет​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Встроены​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Встроены​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Защита памяти​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Нет​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Блок защиты памяти с 8 областями​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Блок защиты памяти с 8 областями​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Производительность по тесту Dhrystone​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0,95 DMIPS/МГц</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,25 DMIPS/МГц​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1,25 DMIPS/МГц​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Энергопотребление ядра​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0,28 мВт/МГц​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0,19 мВт/МГц​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0,19 мВт/МГц​</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Аппаратный модуль работы с плавающей точкой ​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">нет​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">нет​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">есть​</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_характеристики_микроконтроллера">19.3. Характеристики микроконтроллера</h3>
<div id="__asciidoctor-preview-739__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-740__" class="paragraph">
<p>Микроконтроллер имеет следующие характеристики:</p>
</div>
</div>
</div>
<table id="__asciidoctor-preview-741__" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>32 разрядное ядро ARM Cortex-M4</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Блок работы с числами с плавающей точкой FPU</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>512 кБайт памяти программ</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>128 кБайт ОЗУ</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Встроенный 12 битный 16 канальный АЦП</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>DMA контроллер на 16 каналов</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>USB 2.0</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>3x USART</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>5 x SPI/I2S</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>3x I2C</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>SDIO интерфейс для карт SD/MMC/eMMC</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Аппаратный подсчет контрольной суммы памяти программ CRC</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>6 - 16 разрядных и 2 - 32 разрядных Таймера</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>1 - 16 битный для управления двигателями</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>2  сторожевых таймера</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>1 системный таймер</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Работа на частотах до 100Мгц</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>81 портов ввода вывода</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Питание от 1.7 до 3.6 Вольт</p>
</li>
</ul>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Потребление 100 мкА/Мгц</p>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_блок_диаграмма_микроконтроллера">19.4. Блок диаграмма микроконтроллера</h3>
<div id="__asciidoctor-preview-762__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-763__" class="paragraph">
<p>Блок схема микроконтроллера схематично изображена на рисунке <a href="#_блок_диаграмма_микроконтроллера">Блок диаграмма микроконтроллера</a>.</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-764__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure8.png" alt="500" width="500">
</div>
<div class="title">Рисунок 35. Блок диаграмма микроконтроллера</div>
</div>
</div>
<div class="sect2">
<h3 id="_дополнительные_особенности_микроконтроллера">19.5. Дополнительные особенности микроконтроллера</h3>
<div id="__asciidoctor-preview-765__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-766__" class="paragraph">
<p>Из дополнительных особенностей, которые понадобятся для лабораторных работ следует выделить:</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-767__" class="ulist">
<ul>
<li id="__asciidoctor-preview-768__">
<p>Настраиваемые источники тактовой частоты</p>
</li>
<li id="__asciidoctor-preview-769__">
<p>Настраиваемые на различные функции порты</p>
</li>
<li id="__asciidoctor-preview-770__">
<p>Внутренний температурный сенсор</p>
</li>
<li id="__asciidoctor-preview-771__">
<p>Таймеры с настраиваемым модулем ШИМ</p>
</li>
<li id="__asciidoctor-preview-772__">
<p>DMA для работы с модулями (SPI, UART, ADC… )</p>
</li>
<li id="__asciidoctor-preview-773__">
<p>12 разрядный ADC последовательного приближения</p>
</li>
<li id="__asciidoctor-preview-774__">
<p>Часы реального времени</p>
</li>
<li id="__asciidoctor-preview-775__">
<p>Системный таймер и спец. прерывания для облегчения и ускорения  работы ОСРВ</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_система_тактирования">20. Система тактирования</h2>
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="_блок_диаграмма_системы_тактирования">21. Блок диаграмма системы тактирования</h2>
<div class="sectionbody">
<table id="__asciidoctor-preview-776__" class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="content"><div class="imageblock">
<div class="content">
<img src="Lection2Img/Figure13.png" alt="700" width="700">
</div>
<div class="title">Рисунок 36. Система тактирования микроконтроллера STM32F411</div>
</div></div></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="ulist">
<ul>
<li>
<p>Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​</p>
<div class="ulist">
<ul>
<li>
<p>HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​</p>
</li>
<li>
<p>HSE (high-speed external) — внешний высокочастотный генератор.​</p>
</li>
<li>
<p>PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей,
исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Также имеются 2 вторичных источника тактового сигнала:​</p>
<div class="ulist">
<ul>
<li>
<p>LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​</p>
</li>
<li>
<p>LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​</p>
</li>
</ul>
</div>
</li>
</ul>
</div></div></td>
</tr>
</tbody>
</table>
<div class="sect2">
<h3 id="_модуль_тактирования">21.1. Модуль тактирования.</h3>
<div id="__asciidoctor-preview-779__" class="paragraph">
<p>Модуль тактирования (Reset and Clock Control) RCC</p>
</div>
<div id="__asciidoctor-preview-780__" class="ulist">
<ul>
<li id="__asciidoctor-preview-781__">
<p>Для формирования системной тактовой частоты SYSCLK могут использоваться 4 основных источника:​</p>
<div id="__asciidoctor-preview-782__" class="ulist">
<ul>
<li id="__asciidoctor-preview-783__">
<p>HSI (high-speed internal) — внутренний высокочастотный RC-генератор.​</p>
</li>
<li id="__asciidoctor-preview-784__">
<p>HSE (high-speed external) — внешний высокочастотный генератор.​</p>
</li>
<li id="__asciidoctor-preview-785__">
<p>PLL — система ФАПЧ. Точнее сказать, это вовсе и не генератор, а набор из умножителей и делителей,
исходный сигнал он получает от HSI или HSE, а на выходе у него уже другая частота.​</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-786__">
<p>Также имеются 2 вторичных источника тактового сигнала:​</p>
<div id="__asciidoctor-preview-787__" class="ulist">
<ul>
<li id="__asciidoctor-preview-788__">
<p>LSI (low-speed internal) — низкочастотный внутренний RC-генератор на 37 кГц​</p>
</li>
<li id="__asciidoctor-preview-789__">
<p>LSE (low-speed external) — низкочастотный внешний источник на 32,768 кГц​</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_фазовая_подстройка_частоты_pll">21.2. Фазовая подстройка частоты PLL</h3>
<div id="__asciidoctor-preview-790__" class="ulist">
<ul>
<li id="__asciidoctor-preview-791__">
<p>PLL ​Внутренний источник PLL тактируется от внешнего или внутреннего высокочастотных генераторов (HSE либо HSI). ​</p>
<div id="__asciidoctor-preview-792__" class="ulist">
<ul>
<li id="__asciidoctor-preview-793__">
<p>С помощью регистров PLLM, PLLN,PLLP можно подобрать любую частоту до 100 Мгц включительно по формуле:​</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-794__" class="exampleblock">
<div class="content">
<div id="__asciidoctor-preview-795__" class="literalblock">
<div class="content">
<pre>f = f(PLL clock input) × (PLLN / PLLM) /PLLP​</pre>
</div>
</div>
</div>
</div>
<div id="__asciidoctor-preview-796__" class="ulist">
<ul>
<li id="__asciidoctor-preview-797__">
<p>Кроме системной тактовой частоты SYSCLK, PLL также выдает частоту 48 МГц для интерфейса USB.
При использовании USB входная частота для PLL должна быть в диапазоне от 2 МГц до 24 МГц.​</p>
</li>
</ul>
</div>
<div id="__asciidoctor-preview-798__" class="exampleblock">
<div class="content">
<div id="__asciidoctor-preview-799__" class="literalblock">
<div class="content">
<pre>f(USB) = f(PLL clock input) × (PLLN / PLLM) / PLLQ​</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_дополнительные_генераторы_тактовой_частоты">21.3. Дополнительные генераторы тактовой частоты​</h3>
<div id="__asciidoctor-preview-800__" class="ulist">
<ul>
<li id="__asciidoctor-preview-801__">
<p>LSE. Низкочастотный внешний генератор частоты.​</p>
<div id="__asciidoctor-preview-802__" class="ulist">
<ul>
<li id="__asciidoctor-preview-803__">
<p>Применение внешнего кварцевого/керамического резонатора на 32,768 кГц на входах OSC32_IN, OSC32_OUT.
Высокостабильный источник, формирует тактовые сигналы для часов реального времени RTC, модуля ЖКИ,
а также для таймеров TIM9/TIM10/TIM11.​</p>
</li>
<li id="__asciidoctor-preview-804__">
<p>Использование внешнего источника тактовой частоты (режим LSE bypass). Формируются тактовые
сигналы для часов реального времени и ЖКИ. В этом режиме исходный сигнал поступает с генератора HSE.
Входная частота может быть до 1 МГц, затем сигнал проходит через делитель с коэффициентом деления 2,
 4, 8 или 16. Входной сигнал может быть прямоугольной, треугольной формы или синусоидой с 50% скважностью.​</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-805__">
<p>LSI. Внутренний RC-генератор частотой около 37 кГц.</p>
<div id="__asciidoctor-preview-806__" class="ulist">
<ul>
<li id="__asciidoctor-preview-807__">
<p>Как и LSE, позволяет тактировать часы реального времени и модуль ЖКИ. Кроме этого, поддерживает
работоспособность независимого сторожевого таймера IWDG в режимах Stop и Standby.​</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_регистр_управления_частотой">21.4. Регистр управления частотой.</h3>
<div id="__asciidoctor-preview-808__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-809__" class="paragraph">
<p>Clock Control register (CR​)
Как уже упоминалось, системная тактовая частота для серии "STM32F411" может быть до 100 МГц. Для ее
формирования используются 3 основных источника — HSI, HSE, PLL. Включение и выключение основных
генераторов производится через регистр RCC_CR — Clock Control register.</p>
</div>
<div id="__asciidoctor-preview-810__" class="paragraph">
<p>Значение по умолчанию: 0x0000 XX81:​</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-811__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure14.png" alt="800" width="700">
</div>
</div>
<div id="__asciidoctor-preview-812__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 24 PLLON
</td>
<td class="hdlist2">
<p>Включить PLL. Этот бит устанавливается и скидывается программно, чтобы включить PLL.
Бит не может быть скинут, если PLL уже используется как системная частота. ​</p>
<div id="__asciidoctor-preview-815__" class="ulist">
<ul>
<li id="__asciidoctor-preview-816__">
<p><strong>0</strong>: ОТКЛЮЧИТЬ PLL <strong>1</strong>: ВКЛЮЧИТЬ PLL​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-817__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 16: HSEON
</td>
<td class="hdlist2">
<p>Включить HSE. Этот бит устанавливается и скидывается программно.  Бит не может быть
скинут, если HSE уже используется как системная частота. ​</p>
<div id="__asciidoctor-preview-820__" class="ulist">
<ul>
<li id="__asciidoctor-preview-821__">
<p><strong>0</strong>: ОТЛЮЧИТЬ HSE  <strong>1</strong>: ВКЛЮЧИТЬ HSE ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-822__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 0: HSION
</td>
<td class="hdlist2">
<p>Включить HSI. Этот бит устанавливается и скидывается программно. Очищается аппаратно
при входе в режим Stop или Standby.  Бит не может быть скинут, если HSI уже используется как системная частота. ​</p>
<div id="__asciidoctor-preview-825__" class="ulist">
<ul>
<li id="__asciidoctor-preview-826__">
<p><strong>0</strong>: ВЫКЛЮЧИТЬ HSI <strong>1</strong>: ВКЛЮЧИТЬ HSI ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_регистр_управления_частотой_контроль">21.5. Регистр управления частотой. Контроль</h3>
<div id="__asciidoctor-preview-827__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-828__" class="paragraph">
<p>Сразу после установки частоты, нужно проверить, что частота с нового источника стабилизировалась. Для
этого используются те же поля того же регистра CR, оканчивающиеся на RDY (Ready)</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-829__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure14.png" alt="600" width="600">
</div>
</div>
<div id="__asciidoctor-preview-830__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 25 PLLRDY
</td>
<td class="hdlist2">
<p>Флаг готовности частоты PLL. Этот бит устанавливается аппаратно ​</p>
<div id="__asciidoctor-preview-833__" class="ulist">
<ul>
<li id="__asciidoctor-preview-834__">
<p><strong>0</strong>: PLL НЕ  ЗАПУЩЕН И  НЕ ИСПОЛЬЗУЕТСЯ <strong>1</strong>: PLL ИСПОЛЬЗУЕТСЯ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-835__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 17: HSERDY
</td>
<td class="hdlist2">
<p>Флаг готовности частоты  HSE. Этот бит устанавливается аппаратно. ​</p>
<div id="__asciidoctor-preview-838__" class="ulist">
<ul>
<li id="__asciidoctor-preview-839__">
<p><strong>0</strong>: HSE НЕ ГОТОВ <strong>1</strong>: HSE ГОТОВ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-840__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bit 1: HSIRDY
</td>
<td class="hdlist2">
<p>Флаг готовности частоты  HSI. Этот бит устанавливается аппаратно​</p>
<div id="__asciidoctor-preview-843__" class="ulist">
<ul>
<li id="__asciidoctor-preview-844__">
<p><strong>0</strong>: HSI НЕ ГОТОВ <strong>1</strong>: HSI ГОТОВ ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_регистр_конфигурации_частоты_выбор_источника">21.6. Регистр конфигурации частоты. Выбор источника</h3>
<div id="__asciidoctor-preview-845__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-846__" class="paragraph">
<p>После включения генераторов частоты, необходимо выбрать один из них в качестве источника для системной
частоты SYSCLK. Выбор осуществляется через регистр RCC_CFGR — Clock Configuration Register.
Значение по умолчанию: 0x0000 0000​</p>
</div>
</div>
</div>
<div id="__asciidoctor-preview-847__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure14.png" alt="600" width="600">
</div>
</div>
<div id="__asciidoctor-preview-848__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bits 3:2 SWS[1:0]
</td>
<td class="hdlist2">
<p>Статус частоты SYSCLK. ​</p>
<div id="__asciidoctor-preview-851__" class="ulist">
<ul>
<li id="__asciidoctor-preview-852__">
<p><strong>00</strong>: ИСТОЧНИК ЧАСТОТЫ HSI <strong>01</strong>: ИСТОЧНИК ЧАСТОТЫ HSE</p>
</li>
<li id="__asciidoctor-preview-853__">
<p><strong>10</strong>: ИСТОЧНИК ЧАСТОТЫ PLL <strong>11</strong>:  РЕЗЕРВ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-854__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bits 1:0 SW[1:0]
</td>
<td class="hdlist2">
<p>Выбор источника частоты SYSCLK. ​</p>
<div id="__asciidoctor-preview-857__" class="ulist">
<ul>
<li id="__asciidoctor-preview-858__">
<p><strong>00</strong>: HSI  <strong>01</strong>: HSE</p>
</li>
<li id="__asciidoctor-preview-859__">
<p><strong>10</strong>: PLL  <strong>11</strong>: НЕ ИСПОЛЬЗУЕТСЯ</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_регистр_конфигурации_частоты_делители">21.7. Регистр конфигурации частоты. Делители</h3>
<div id="__asciidoctor-preview-860__" class="paragraph">
<p>Следующие секции регистра HPRE (AHB prescaler), PPRE1 (APB1 prescaler), PPRE2 (APB2 prescaler) —
задают коэффициенты деления системной частоты SYSCLK, которая после предделителей поступает на
матрицы шин. ​</p>
</div>
<div id="__asciidoctor-preview-861__" class="openblock notes">
<div class="content">
<div id="__asciidoctor-preview-862__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
AHB (Advanced High Speed Busses)
</td>
<td class="hdlist2">
<p>матрица высокоскоростных шин. Она "доставляет" сигналы
тактирования к ядру микроконтроллера, памяти (это как FLASH, так EEPROM и RAM) и модулю DMA
Direct Memory Access — модуль прямого доступа к памяти), системному таймеру. Также, в семействе
STM32F4 на эту шину "посажены" и все порты ввода/вывода GPIO .</p>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-865__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
APB1, APB2 (Advanced Peripheral Bussess)
</td>
<td class="hdlist2">
<p>матрицы шин периферии. Соотвественно, к остальным
периферийным модулям тактовая частота распределяется уже через эти шины. ​</p>
</td>
</tr>
</table>
</div>
</div>
</div>
<div id="__asciidoctor-preview-868__" class="imageblock">
<div class="content">
<img src="Lection2Img/Figure14.png" alt="600" width="600">
</div>
</div>
<div id="__asciidoctor-preview-869__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bits 13:11 PPRE2[2:0]
</td>
<td class="hdlist2">
<p>Делитель частоты шины APB2. Это устанавливается и очищается программно. ​</p>
<div id="__asciidoctor-preview-872__" class="ulist">
<ul>
<li id="__asciidoctor-preview-873__">
<p><strong>0xx</strong>: AHB      <strong>100</strong>: AHB/2     <strong>101</strong>: AHB/4     <strong>110</strong>: AHB/8    <strong>111</strong>: AHB/16 ​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-874__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bits 10:8 PPRE1[2:0]
</td>
<td class="hdlist2">
<p>Делитель частоты шины APB1 Это устанавливается и очищается программно. ​</p>
<div id="__asciidoctor-preview-877__" class="ulist">
<ul>
<li id="__asciidoctor-preview-878__">
<p><strong>0xx</strong>: AHB     <strong>100</strong>: AHB/2      <strong>101</strong>: AHB/4     <strong>110</strong>: AHB/8     <strong>111</strong>: AHB/16​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
<div id="__asciidoctor-preview-879__" class="hdlist">
<table>
<tr>
<td class="hdlist1">
Bits 7:4 HPRE[3:0]
</td>
<td class="hdlist2">
<p>Делитель частоты шины AHB. ​</p>
<div id="__asciidoctor-preview-882__" class="ulist">
<ul>
<li id="__asciidoctor-preview-883__">
<p><strong>0xxx</strong>: SYSCLK    <strong>1000</strong>: SYSCLK/2     <strong>1001</strong>: SYSCLK/4     <strong>1010</strong>: SYSCLK/8     <strong>1011</strong>: SYSCLK/16    ​
<strong>1100</strong>: SYSCLK/64  <strong>1101</strong>: SYSCLK/128  <strong>1110</strong>: SYSCLK/256   <strong>1111</strong>: SYSCLK/512​</p>
</li>
</ul>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect2">
<h3 id="_алгоритм_настройки_частоты">21.8. Алгоритм настройки частоты​</h3>
<div id="__asciidoctor-preview-884__" class="ulist">
<ul>
<li id="__asciidoctor-preview-885__">
<p>Определить какие источники частоты нужны​</p>
<div id="__asciidoctor-preview-886__" class="ulist">
<ul>
<li id="__asciidoctor-preview-887__">
<p>Например, PLL нужен для USB​</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-888__">
<p>Включить нужный источник​</p>
<div id="__asciidoctor-preview-889__" class="ulist">
<ul>
<li id="__asciidoctor-preview-890__">
<p>Используя Clock Control register (RCC::CR)​</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-891__">
<p>Дождаться стабилизации источника ​</p>
<div id="__asciidoctor-preview-892__" class="ulist">
<ul>
<li id="__asciidoctor-preview-893__">
<p>Используя соответствующие биты (..RDY) Clock Control register ​(RCC::CR)</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-894__">
<p>Назначить нужный источник на системную частоту​</p>
<div id="__asciidoctor-preview-895__" class="ulist">
<ul>
<li id="__asciidoctor-preview-896__">
<p>Используя Clock Configuration Register (RCC::CFGR)​</p>
</li>
</ul>
</div>
</li>
<li id="__asciidoctor-preview-897__">
<p>Дождаться пока источник не переключиться на системную частоту​</p>
<div id="__asciidoctor-preview-898__" class="ulist">
<ul>
<li id="__asciidoctor-preview-899__">
<p>Используя Clock Configuration Register (RCC::CFGR)​</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_контрольные_вопросы">22. Контрольные вопросы</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-900__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-901__">
<p>Что такое POD типы данных?</p>
</li>
<li id="__asciidoctor-preview-902__">
<p>Назовите все виды типов в языке С++</p>
</li>
<li id="__asciidoctor-preview-903__">
<p>Что такое пользовательский тип?</p>
</li>
<li id="__asciidoctor-preview-904__">
<p>Назовите модификаторы типов.</p>
</li>
<li id="__asciidoctor-preview-905__">
<p>Назовите правило установки размеров типов</p>
</li>
<li id="__asciidoctor-preview-906__">
<p>Что делает оператор sizeof()?</p>
</li>
<li id="__asciidoctor-preview-907__">
<p>Что характеризует тип std::size_t</p>
</li>
<li id="__asciidoctor-preview-908__">
<p>Назовите фиксированные типы целых в библиотеке std</p>
</li>
<li id="__asciidoctor-preview-909__">
<p>Что такое псевдоним типа?</p>
</li>
<li id="__asciidoctor-preview-910__">
<p>Что такое явное и неявное преобразование типа?</p>
</li>
<li id="__asciidoctor-preview-911__">
<p>Какие явные преобразования типов вы знаете?</p>
</li>
<li id="__asciidoctor-preview-912__">
<p>Что делает reinterpret_cast?</p>
</li>
<li id="__asciidoctor-preview-913__">
<p>Чем static_cast отличается от reinterpret_cast?</p>
</li>
<li id="__asciidoctor-preview-914__">
<p>Что такое ОЗУ и ПЗУ?</p>
</li>
<li id="__asciidoctor-preview-915__">
<p>Каков размер памяти ARM Cortex микроконтроллеров.</p>
</li>
<li id="__asciidoctor-preview-916__">
<p>По какой архитектуре разработан ARM Cortex микроконтроллер?</p>
</li>
<li id="__asciidoctor-preview-917__">
<p>В чем отличие Гарвардской архитектуры от Архитектура ФонНеймана?</p>
</li>
<li id="__asciidoctor-preview-918__">
<p>Где располагаются локальные переменные?</p>
</li>
<li id="__asciidoctor-preview-919__">
<p>Где располагаются статические переменные?</p>
</li>
<li id="__asciidoctor-preview-920__">
<p>Где располагаются глобальные переменные?</p>
</li>
<li id="__asciidoctor-preview-921__">
<p>Что такое стек?</p>
</li>
<li id="__asciidoctor-preview-922__">
<p>Что такое указатель?</p>
</li>
<li id="__asciidoctor-preview-923__">
<p>Что такое разыменовывание указателя?</p>
</li>
<li id="__asciidoctor-preview-924__">
<p>Что означает взятие адреса?</p>
</li>
<li id="__asciidoctor-preview-925__">
<p>Какие операции можно выполнять над указателями?</p>
</li>
<li id="__asciidoctor-preview-926__">
<p>Что такое константный указатель?</p>
</li>
<li id="__asciidoctor-preview-927__">
<p>Что такое указатель на константу?</p>
</li>
<li id="__asciidoctor-preview-928__">
<p>Что такое ссылка? В чем её отличие от указателя?</p>
</li>
<li id="__asciidoctor-preview-929__">
<p>Что такое регистр?</p>
</li>
<li id="__asciidoctor-preview-930__">
<p>Что такое регистры общего назначения?</p>
</li>
<li id="__asciidoctor-preview-931__">
<p>Что такое регистры специального назначения?</p>
</li>
<li id="__asciidoctor-preview-932__">
<p>Как можно установить бит в регистре специального назначения?</p>
</li>
<li id="__asciidoctor-preview-933__">
<p>Объясните как вызывается функция.</p>
</li>
<li id="__asciidoctor-preview-934__">
<p>Что такое трансляция?</p>
</li>
<li id="__asciidoctor-preview-935__">
<p>Что такое компоновка?</p>
</li>
<li id="__asciidoctor-preview-936__">
<p>Как лучше организовывать структуру проекта и почему?</p>
</li>
<li id="__asciidoctor-preview-937__">
<p>Что такое операторы?</p>
</li>
<li id="__asciidoctor-preview-938__">
<p>Какие арифметические операторы вы знаете?</p>
</li>
<li id="__asciidoctor-preview-939__">
<p>Какие логические операторы вы знаете?</p>
</li>
<li id="__asciidoctor-preview-940__">
<p>Какие побитовые операторы вы знаете?</p>
</li>
<li id="__asciidoctor-preview-941__">
<p>Приведите пример переопределения оператора</p>
</li>
<li id="__asciidoctor-preview-942__">
<p>Какие еще операторы вы знаете?</p>
</li>
<li id="__asciidoctor-preview-943__">
<p>Как сбросить бит с помощью битовых операторов?</p>
</li>
<li id="__asciidoctor-preview-944__">
<p>Как установить бит с помощью битовых операторов?</p>
</li>
<li id="__asciidoctor-preview-945__">
<p>Как поменять значение бита с помощью битовых операторов?</p>
</li>
<li id="__asciidoctor-preview-946__">
<p>Какой микроконтроллер на отладочной плате XNUCLE ST32F411?</p>
</li>
<li id="__asciidoctor-preview-947__">
<p>Какие блоки входят в состав микроконтроллера STM32F411?</p>
</li>
<li id="__asciidoctor-preview-948__">
<p>В чем отличие ядра CortexM4 от CortexM3?</p>
</li>
<li id="__asciidoctor-preview-949__">
<p>Назовите основные характеристики микроконтроллера STM32F411.</p>
</li>
<li id="__asciidoctor-preview-950__">
<p>Назовите дополнительные характеристики микроконтроллера STM32F411.</p>
</li>
<li id="__asciidoctor-preview-951__">
<p>Какие источники тактирования есть у микроконтроллера STM32F411</p>
</li>
<li id="__asciidoctor-preview-952__">
<p>Назовите алгоритм подключения системной частоты к источнику тактирования микроконтроллера STM32F411.</p>
</li>
<li id="__asciidoctor-preview-953__">
<p>Что такое ФАПЧ?</p>
</li>
<li id="__asciidoctor-preview-954__">
<p>Что делает следующий код?</p>
</li>
</ol>
</div>
<div id="__asciidoctor-preview-955__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">int main()
{
  int StudentUdacha = 10;
  int PrepodUdachca = 0 ;

  StudentUdacha =  StudentUdacha ^ PrepodUdachca ;
  PrepodUdachca =  StudentUdacha ^ PrepodUdachca ;
  StudentUdacha ^= PrepodUdachca ;
}</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_задания_2">23. Задания</h2>
<div class="sectionbody">
<div id="__asciidoctor-preview-956__" class="paragraph">
<p>3 Задания, кто не успеет в лабораторной, завершить дома.</p>
</div>
<div class="sect2">
<h3 id="_содержание_отчета">23.1. Содержание отчета</h3>
<div id="__asciidoctor-preview-957__" class="ulist">
<ul>
<li id="__asciidoctor-preview-958__">
<p>Описать процесс записи в регистр по его адресу</p>
</li>
<li id="__asciidoctor-preview-959__">
<p>Описать полученный результат записи в регистры MODER и ODR</p>
</li>
<li id="__asciidoctor-preview-960__">
<p>Описать процесс вызова функции в IAR</p>
</li>
<li id="__asciidoctor-preview-961__">
<p>Описать регистры общего назначения для семейства Cortex-m4</p>
</li>
<li id="__asciidoctor-preview-962__">
<p>Описать все виды источников тактирования параметры их настройки</p>
</li>
<li id="__asciidoctor-preview-963__">
<p>Описать процесс получения заданной по варианту частоты тактирования</p>
</li>
<li id="__asciidoctor-preview-964__">
<p>Описать ошибки, сделанные при выполнении работы</p>
</li>
<li id="__asciidoctor-preview-965__">
<p>Ответить на контрольные вопросы</p>
</li>
<li id="__asciidoctor-preview-966__">
<p>Сделать выводы</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_задание_1">23.2. Задание 1</h3>
<div id="__asciidoctor-preview-967__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-968__">
<p>Создать проект в соответствии с Заданием 1 Лекции 1</p>
</li>
<li id="__asciidoctor-preview-969__">
<p>Написать программу в main.cpp</p>
</li>
</ol>
</div>
<div id="__asciidoctor-preview-970__" class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code data-lang="cpp" class="language-cpp hljs">#include "rccregisters.hpp"   //for RCC
int main() {
  RCC::AHB1ENR::GPIOCEN::Enable::Set() ;
  for(;;) {
    //код лабораторной здесь.
  }
  return 0 ;
}</code></pre>
</div>
</div>
<div id="__asciidoctor-preview-971__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-972__">
<p>Открыть спецификацию на микроконтроллер <a href="https://www.st.com/resource/en/reference_manual/dm00119316.pdf#STM32F411">STM32F411</a>.
на странице 38, узнать на каком адресе расположен модуль GPIOC, на странице 157, узнать смещение регистра
GPIOС_MODER относительно адреса GPIOC и вычислить адрес регистра GPIOC_MODER</p>
</li>
<li id="__asciidoctor-preview-973__">
<p>Записать по адресу регистра GPIOC_MODER биты номер 10,16,18 в 1, а биты номер 11,17,19 в 0.</p>
</li>
<li id="__asciidoctor-preview-974__">
<p>Открыть спецификацию на микроконтроллер <a href="https://www.st.com/resource/en/reference_manual/dm00119316.pdf#STM32F411">STM32F411</a>.
на странице 38, узнать на каком адресе расположен модуль GPIOC, на странице 159, узнать смещение регистра
GPIOС_ODR относительно адреса GPIOC и вычислить адрес регистра GPIOC_ODR</p>
</li>
<li id="__asciidoctor-preview-975__">
<p>Записать по адресу регистра GPIOC_ODR биты номер 5,8,9 в 1</p>
</li>
<li id="__asciidoctor-preview-976__">
<p>Написать функцию задержки используя цикл void Delay(). И вызвать ей после установки битов</p>
</li>
<li id="__asciidoctor-preview-977__">
<p>После задержки Записать по адресу регистра GPIOC_ODR биты номер 5,8,9 в 0</p>
</li>
<li id="__asciidoctor-preview-978__">
<p>Вызвать функцию сброса битов</p>
</li>
<li id="__asciidoctor-preview-979__">
<p>Запустить программу, в пошаговой отладке в окне Register, посмотреть, что происходит с регистрами
GPIOС_MODER и GPIOС_ODR.</p>
</li>
<li id="__asciidoctor-preview-980__">
<p>Посмотреть видео <a href="https://www.youtube.com/watch?v=hukr8ZqS5Ys" class="bare">https://www.youtube.com/watch?v=hukr8ZqS5Ys</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_задание_2_2">23.3. Задание 2</h3>
<div id="__asciidoctor-preview-981__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-982__">
<p>Создать указатель типа <strong>volatile int</strong>*, которая будет содержать адрес регистра GPIOC_MODER</p>
</li>
<li id="__asciidoctor-preview-983__">
<p>Создать переменную типа <strong>int</strong> и записать туда значение, которое содержится по этому адресу</p>
</li>
<li id="__asciidoctor-preview-984__">
<p>Запустить отладку, запустить окно Memory и проверить, что по этому адресу лежит это значение</p>
</li>
<li id="__asciidoctor-preview-985__">
<p>В отладке открыть окно регистры и проверить, что значение регистра GPIOC_MODER, совпадает со значением
в переменной типа <strong>int</strong></p>
</li>
<li id="__asciidoctor-preview-986__">
<p>Проделать тоже самое с произвольным адресом в ОЗУ.</p>
</li>
<li id="__asciidoctor-preview-987__">
<p>Посмотреть видео <a href="https://www.youtube.com/watch?v=M53lJlcFOZQ" class="bare">https://www.youtube.com/watch?v=M53lJlcFOZQ</a></p>
</li>
</ol>
</div>
</div>
<div class="sect2">
<h3 id="_задание_3_2">23.4. Задание 3</h3>
<div id="__asciidoctor-preview-988__" class="olist arabic">
<ol class="arabic">
<li id="__asciidoctor-preview-989__">
<p>Ознакомиться с техническим описанием регистров тактирования микропроцессора</p>
</li>
<li id="__asciidoctor-preview-990__">
<p>Произвести настройку тактирования микропроцессора по варианту см. <a href="#Варианты для системы тактирования">[Варианты для системы тактирования]</a></p>
</li>
<li id="__asciidoctor-preview-991__">
<p>Выполнить пошаговую отладку</p>
</li>
</ol>
</div>
<table id="__asciidoctor-preview-992__" class="tableblock frame-all grid-all stretch">
<caption class="title">Таблица 7. Варианты для системы тактирования</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Номер варианта</th>
<th class="tableblock halign-left valign-top">Источник тактирования</th>
<th class="tableblock halign-left valign-top">Частота тактирования</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSI</p></td>
<td class="tableblock halign-center valign-middle" rowspan="3"><p class="tableblock">1 Мгц</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PLL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSI</p></td>
<td class="tableblock halign-center valign-middle" rowspan="3"><p class="tableblock">2 Мгц</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PLL</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSI</p></td>
<td class="tableblock halign-center valign-middle" rowspan="3"><p class="tableblock">4 Мгц</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">HSE</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PLL</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_библиография">24. Библиография</h2>
<div class="sectionbody">
<div id="1" class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Недяк С.П., Шаропин Ю.Б. Лабораторный практикум по микроконтроллерам семейства Cortex-M:
Методическое пособие по проведению работ на отладочных платах фирмы "Миландр"- Томск. гос. ун-т
систем упр. и радиоэлектроники, 2017. - 110 с.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>Волков В.Л. Программное обеспечение измерительных процессов. Учебное пособие для студентов
технических специальностей дневной, заочной, и заочной форм обучения. /АПИ НГТУ. Арзамас,
2008 – 120 с.</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>Руководство по оформлению кода на С++ Стэнфордского университета:
<a href="http://stanford.edu/class/archive/cs/cs106b/cs106b.1158/styleguide.shtml" class="bare">http://stanford.edu/class/archive/cs/cs106b/cs106b.1158/styleguide.shtml</a></td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>Объектно-ориентированное программирование:
<a href="https://ru.wikipedia.org/wiki" class="bare">https://ru.wikipedia.org/wiki</a></td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>Можно ли использовать С++ вместо Си для небольших проектов в микроконтроллерах:
<a href="https://habr.com/post/347980/" class="bare">https://habr.com/post/347980/</a></td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>AsciiDoc шпаргалка: <a href="https://powerman.name/doc/asciidoc" class="bare">https://powerman.name/doc/asciidoc</a></td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>Reveal.js: <a href="https://github.com/hakimel/reveal.js#full-setup" class="bare">https://github.com/hakimel/reveal.js#full-setup</a></td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td>Asciidoctor Reveal.js: <a href="https://asciidoctor.org/docs/asciidoctor-revealjs/#node-javascript-setup" class="bare">https://asciidoctor.org/docs/asciidoctor-revealjs/#node-javascript-setup</a></td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td>Где хранятся ваши константы на микроконтроллере CortexM: <a href="https://habr.com/ru/post/453262/" class="bare">https://habr.com/ru/post/453262/</a></td>
</tr>
<tr>
<td><i class="conum" data-value="10"></i><b>10</b></td>
<td>Обзор одной российской RTOS, часть 4. Полезная теория: <a href="https://habr.com/post/337476/" class="bare">https://habr.com/post/337476/</a></td>
</tr>
<tr>
<td><i class="conum" data-value="11"></i><b>11</b></td>
<td>Начинаем изучать STM32: Что такое регистры? Как с ними работать? <a href="https://habr.com/ru/post/407083/" class="bare">https://habr.com/ru/post/407083/</a></td>
</tr>
<tr>
<td><i class="conum" data-value="12"></i><b>12</b></td>
<td>Справочное руководство на микроконтроллер STM32F411 <a href="https://www.st.com/resource/en/reference_manual/dm00119316.pdf" class="bare">https://www.st.com/resource/en/reference_manual/dm00119316.pdf</a></td>
</tr>
<tr>
<td><i class="conum" data-value="13"></i><b>13</b></td>
<td>Безопасный доступ к полям регистров на С++ без ущерба эффективности (на примере CortexM) <a href="https://habr.com/ru/post/459642/" class="bare">https://habr.com/ru/post/459642/</a></td>
</tr>
</table>
</div>
</div>
</div>
        </div>
      </div>
    </body>
  </html>
